// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OrdersOrder is an auto generated low-level Go binding around an user-defined struct.
type OrdersOrder struct {
	Maker      common.Address
	IsBuy      bool
	LimitPrice *big.Int
	Amount     *big.Int
	Instrument *big.Int
	Salt       *big.Int
	Fee        *big.Int
	Signature  []byte
	OrderMode  uint8
	Id         *big.Int
}

// ExchangeMetaData contains all meta data concerning the Exchange contract.
var ExchangeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_domain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Initialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"takerHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"makerHash\",\"type\":\"bytes32\"},{\"internalType\":\"enumExchangeInterface.RevertReason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidMakerOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"takerHash\",\"type\":\"bytes32\"},{\"internalType\":\"enumExchangeInterface.RevertReason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidTakerOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthority\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotKeeper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accounts\",\"type\":\"address\"}],\"name\":\"AccountsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"order\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"}],\"name\":\"Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"takerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"makerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Fill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instruments\",\"type\":\"address\"}],\"name\":\"InstrumentsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"KeeperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"takerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newVersion\",\"type\":\"uint256\"}],\"name\":\"VersionInitialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorities\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instruments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keepers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accounts\",\"type\":\"address\"}],\"name\":\"setAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instruments\",\"type\":\"address\"}],\"name\":\"setInstruments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"orderMode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"structOrders.Order\",\"name\":\"taker\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"orderMode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"structOrders.Order[]\",\"name\":\"makers\",\"type\":\"tuple[]\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerFill\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"takerPnL\",\"type\":\"int256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerFills\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[]\",\"name\":\"makerPnLs\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
	Bin: "0x60c0604052306080523480156200001557600080fd5b5060405162003496380380620034968339810160408190526200003891620001ae565b6200004f82826200005b60201b62000d591760201c565b60a052506200028e9050565b6040516c08a92a06e626488dedac2d2dc5609b1b60208201526b1cdd1c9a5b99c81b985b594b60a21b602d8201526e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b60398201526e1d5a5b9d0c8d4d8818da185a5b9259608a1b6048820152602960f81b60578201526000906058016040516020818303038152906040528051906020012083604051602001620000f2919062000270565b60408051601f198184030181528282528051602091820120908301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201526080810183905260a00160405160208183030381529060405280519060200120905092915050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620001985781810151838201526020016200017e565b83811115620001a8576000848401525b50505050565b60008060408385031215620001c257600080fd5b82516001600160401b0380821115620001da57600080fd5b818501915085601f830112620001ef57600080fd5b81518181111562000204576200020462000165565b604051601f8201601f19908116603f011681019083821181831017156200022f576200022f62000165565b816040528281528860208487010111156200024957600080fd5b6200025c8360208301602088016200017b565b602097909701519698969750505050505050565b60008251620002848184602087016200017b565b9190910192915050565b60805160a0516131b8620002de6000396000818161039701528181610971015261153e015260008181610459015281816104a20152818161053e0152818161057e015261061101526131b86000f3fe6080604052600436106101095760003560e01c8063667e67151161009557806391223d691161006457806391223d6914610315578063c4d66de814610345578063d305787714610365578063f698da2514610385578063fce52eae146103b957600080fd5b8063667e67151461029557806368cd03f6146102b55780636cd22eaf146102d55780638da5cb5b146102f557600080fd5b80632e463e92116100dc5780632e463e92146101d55780633659cfe61461020d5780633bbd64bc1461022d5780634f1ef2861461026d57806352d1902d1461028057600080fd5b806306fdde031461010e578063082743821461015857806313af40351461017a57806320158c441461019a575b600080fd5b34801561011a57600080fd5b506101426040518060400160405280600881526020016745786368616e676560c01b81525081565b60405161014f91906129aa565b60405180910390f35b34801561016457600080fd5b506101786101733660046129fd565b6103e9565b005b34801561018657600080fd5b506101786101953660046129fd565b61043b565b3480156101a657600080fd5b506101c76101b5366004612a1a565b60076020526000908152604090205481565b60405190815260200161014f565b3480156101e157600080fd5b506006546101f5906001600160a01b031681565b6040516001600160a01b03909116815260200161014f565b34801561021957600080fd5b506101786102283660046129fd565b61044f565b34801561023957600080fd5b5061025d6102483660046129fd565b60046020526000908152604090205460ff1681565b604051901515815260200161014f565b61017861027b366004612b00565b610534565b34801561028c57600080fd5b506101c7610604565b3480156102a157600080fd5b506101786102b03660046129fd565b6106b7565b3480156102c157600080fd5b506005546101f5906001600160a01b031681565b3480156102e157600080fd5b506101786102f0366004612b69565b610709565b34801561030157600080fd5b506000546101f5906001600160a01b031681565b34801561032157600080fd5b5061025d6103303660046129fd565b60036020526000908152604090205460ff1681565b34801561035157600080fd5b506101786103603660046129fd565b61078c565b34801561037157600080fd5b50610178610380366004612b69565b610804565b34801561039157600080fd5b506101c77f000000000000000000000000000000000000000000000000000000000000000081565b3480156103c557600080fd5b506103d96103d4366004612ba2565b610887565b60405161014f9493929190612c45565b6103f1610e62565b600580546001600160a01b0319166001600160a01b0383169081179091556040517fbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d90600090a250565b610443610e62565b61044c81610e8e565b50565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036104a05760405162461bcd60e51b815260040161049790612cd2565b60405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166104e9600080516020613165833981519152546001600160a01b031690565b6001600160a01b03161461050f5760405162461bcd60e51b815260040161049790612d1e565b61051881610efd565b6040805160008082526020820190925261044c91839190610f05565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016300361057c5760405162461bcd60e51b815260040161049790612cd2565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166105c5600080516020613165833981519152546001600160a01b031690565b6001600160a01b0316146105eb5760405162461bcd60e51b815260040161049790612d1e565b6105f482610efd565b61060082826001610f05565b5050565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106a45760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152608401610497565b5060008051602061316583398151915290565b6106bf610e62565b600680546001600160a01b0319166001600160a01b0383169081179091556040517f50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa90600090a250565b610711610e62565b6001600160a01b0382166107385760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b038216600081815260036020526040808220805460ff191685151590811790915590519092917fc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc91a35050565b60016107988180612d80565b600154146107b9576040516302ed543d60e51b815260040160405180910390fd5b806001036107c75760016002555b6107d082610e8e565b600181905560405181907f7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d90600090a25050565b61080c610e62565b6001600160a01b0382166108335760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b038216600081815260046020526040808220805460ff191685151590811790915590519092917f786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c0091a35050565b600080606080610895611075565b60408051610160810182526000818301819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101408201526005546001600160a01b03908116808352600654909116602080840191909152835163999b93af60e01b815293519293919263999b93af9260048082019392918290030181865afa15801561093a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095e9190612d97565b6001600160a01b0316606082015261099f7f00000000000000000000000000000000000000000000000000000000000000006109998a612dc5565b9061109e565b60a08201523360009081526004602052604090205460ff166109dd578060a001516007604051636be134e360e01b8152600401610497929190612eb6565b60208101516040516322bbad0b60e01b815260808a013560048201526001600160a01b03909116906322bbad0b90602401602060405180830381865afa158015610a2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a4f9190612eca565b81604001906002811115610a6557610a65612e7e565b90816002811115610a7857610a78612e7e565b905250600081604001516002811115610a9357610a93612e7e565b03610aba578060a00151600d604051636be134e360e01b8152600401610497929190612eb6565b602081015160405163c7f9df8b60e01b815260808a013560048201526001600160a01b039091169063c7f9df8b90602401602060405180830381865afa158015610b08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2c9190612eeb565b15610b53578060a001516008604051636be134e360e01b8152600401610497929190612eb6565b610b668160000151898360a00151611333565b610b8c578060a001516009604051636be134e360e01b8152600401610497929190612eb6565b60a08101516000908152600760205260409020546060890135811115610bce578160a00151600a604051636be134e360e01b8152600401610497929190612eb6565b610bdc8160608b0135612d80565b6101208301528667ffffffffffffffff811115610bfb57610bfb612a33565b604051908082528060200260200182016040528015610c24578160200160208202803683370190505b5093508667ffffffffffffffff811115610c4057610c40612a33565b604051908082528060200260200182016040528015610c69578160200160208202803683370190505b50925050600080610c87838b610c7e90612dc5565b8b8b89896114cc565b9092509050600081600e811115610ca057610ca0612e7e565b14610cf4578260a001518203610cd1578260a0015181604051636be134e360e01b8152600401610497929190612eb6565b8260a001518282604051631761c9a760e31b815260040161049793929190612f08565b89606001358361012001511115610d27578260a00151600b604051636be134e360e01b8152600401610497929190612eb6565b610120830151610d3b9060608c0135612d80565b96508261014001519550505050600160028190555093509350935093565b6040516c08a92a06e626488dedac2d2dc5609b1b60208201526b1cdd1c9a5b99c81b985b594b60a21b602d8201526e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b60398201526e1d5a5b9d0c8d4d8818da185a5b9259608a1b6048820152602960f81b60578201526000906058016040516020818303038152906040528051906020012083604051602001610dee9190612f23565b60408051601f198184030181528282528051602091820120908301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201526080810183905260a0016040516020818303038152906040528051906020012090505b92915050565b6000546001600160a01b03163314610e8c576040516282b42960e81b815260040160405180910390fd5b565b6001600160a01b038116610eb55760405163d92e233d60e01b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b61044c610e62565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615610f3d57610f3883611868565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015610f97575060408051601f3d908101601f19168201909252610f9491810190612f3f565b60015b610ffa5760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b6064820152608401610497565b60008051602061316583398151915281146110695760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b6064820152608401610497565b50610f38838383611904565b6002546001146110985760405163558a1e0360e11b815260040160405180910390fd5b60028055565b6000600160ff1683610100015160ff16036111845761117d82604051602001611111906a08cdee4c6ca9ee4c8cae4560ab1b8152721d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d0b606a1b600b820152691d5a5b9d0c8d4d881a5960b21b601e820152602960f81b602882015260290190565b60408051601f1981840301815282825280516020918201206080808a01516101208b015193860192909252928401526060830152015b6040516020818303038152906040528051906020012061190160f01b600090815260029290925260229081526042822091905290565b9050610e5c565b600260ff1683610100015160ff16036111fb5761117d826040516020016111119070098d2e2ead2c8c2e8d2dedc9ee4c8cae45607b1b8152721d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d0b606a1b6011820152691d5a5b9d0c8d4d881a5960b21b6024820152602960f81b602e820152602f0190565b61117d826040516020016112b5906509ee4c8cae4560d31b81526d1859191c995cdcc81b585ad95c8b60921b60068201526a189bdbdb081a5cd09d5e4b60aa1b6014820152721d5a5b9d0c8d4d881b1a5b5a5d141c9a58d94b606a1b601f8201526e1d5a5b9d0c8d4d88185b5bdd5b9d0b608a1b60328201526c1d5a5b9d0c8d4d881cd85b1d0b609a1b6041820152711d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d60721b604e820152602960f81b606082015260610190565b6040516020818303038152906040528051906020012085600001518660200151876040015188606001518960a001518a6080015160405160200161114797969594939291909687526001600160a01b0395909516602087015292151560408601526060850191909152608084015260a083015260c082015260e00190565b60008061134360208501856129fd565b6001600160a01b0316146114c157600061136561012085016101008601612f58565b60ff16036114ae5761137a60e0840184612f73565b905060000361138b575060006114c5565b60006113d88361139e60e0870187612f73565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061192f92505050565b90506113e760208501856129fd565b6001600160a01b0316816001600160a01b0316036114095760019150506114c5565b6001600160a01b0385166362946d3b61142560208701876129fd565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529084166024820152604401602060405180830381865afa158015611471573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114959190612eeb565b156114a45760019150506114c5565b60009150506114c5565b610120830135156114c1575060016114c5565b5060005b9392505050565b60008060006114e9898a60a001518a600001518b60c00151611a52565b9050600081600e8111156114ff576114ff612e7e565b146115125760a08901519250905061185d565b60005b868110156118535789610120015160000361153957506000925082915061185d9050565b61158a7f000000000000000000000000000000000000000000000000000000000000000089898481811061156f5761156f612fc1565b90506020028101906115819190612fd7565b61099990612dc5565b60c08b01528787828181106115a1576115a1612fc1565b90506020028101906115b39190612fd7565b6115c4906040810190602001612fee565b151589602001511515036115e2575050505060c0860151600c61185d565b8787828181106115f4576115f4612fc1565b90506020028101906116069190612fd7565b60800135896080015114611624575050505060c0860151600d61185d565b6116588a8a8a8a8581811061163b5761163b612fc1565b905060200281019061164d9190612fd7565b8d6101200151611da3565b6101008d019190915260e08c01919091529150600082600e81111561167f5761167f612e7e565b14611693575060c08901519250905061185d565b60e08a0151156118435760e08a015160a08b0151600090815260076020526040812080549091906116c590849061300b565b909155505060e08a015160c08b0151600090815260076020526040812080549091906116f290849061300b565b909155505060e08a01516101208b01805161170e908390612d80565b90525060e08a0151865187908390811061172a5761172a612fc1565b602002602001018181525050600061176f8b8b8b8b8681811061174f5761174f612fc1565b90506020028101906117619190612fd7565b61176a90612dc5565b611ebe565b88858151811061178157611781612fc1565b60209081029190910101529093509050600083600e8111156117a5576117a5612e7e565b146117ba57505060c08901519250905061185d565b808b610140018181516117cd9190613023565b90525060c0808c01518b51918c01516117e8928e9291611a52565b9250600083600e8111156117fe576117fe612e7e565b1461181357505060c08901519250905061185d565b6118418b8b8b8b8681811061182a5761182a612fc1565b905060200281019061183c9190612fd7565b612264565b505b61184c81613064565b9050611515565b5060009250829150505b965096945050505050565b6001600160a01b0381163b6118d55760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b6064820152608401610497565b60008051602061316583398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b61190d8361230c565b60008251118061191a5750805b15610f3857611929838361234c565b50505050565b600080600080845160400361196157505050602082015160408301516001600160ff1b0381169060ff1c601b016119b6565b84516041036119aa5750505060208201516040830151606084015160001a601b811480159061199457508060ff16601c14155b156119a55760009350505050610e5c565b6119b6565b60009350505050610e5c565b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08211156119ea5760009350505050610e5c565b60408051600081526020810180835288905260ff831691810191909152606081018490526080810183905260019060a0016020604051602081039080840390855afa158015611a3d573d6000803e3d6000fd5b5050604051601f190151979650505050505050565b600080821315611bf0578451606086015160405163131384f360e11b81526000926001600160a01b03169163262709e691611a93918891889060040161307d565b60408051808303816000875af1158015611ab1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ad591906130a1565b91506000905081600c811115611aed57611aed612e7e565b14611b0357611afb81612371565b915050611d9b565b855160808701516060880151604051637de182c560e01b81526001600160a01b0390931692637de182c592611b3e929091889060040161307d565b60408051808303816000875af1158015611b5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b8091906130a1565b91506000905081600c811115611b9857611b98612e7e565b14611ba657611afb81612371565b836001600160a01b0316857fb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec85604051611be291815260200190565b60405180910390a350611d97565b6000821215611d9757600085600001516001600160a01b031663262709e68760800151886060015186611c22906130ca565b6040518463ffffffff1660e01b8152600401611c409392919061307d565b60408051808303816000875af1158015611c5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c8291906130a1565b91506000905081600c811115611c9a57611c9a612e7e565b14611ca857611afb81612371565b85600001516001600160a01b0316637de182c585886060015186611ccb906130ca565b6040518463ffffffff1660e01b8152600401611ce99392919061307d565b60408051808303816000875af1158015611d07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d2b91906130a1565b91506000905081600c811115611d4357611d43612e7e565b14611d5157611afb81612371565b836001600160a01b0316857fb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec85604051611d8d91815260200190565b60405180910390a3505b5060005b949350505050565b6000806000611dbb8760000151868960c00151611333565b611dce5750600091508190506009611eb4565b8560200151611de7578460400135866040015111611df3565b84604001358660400151105b15611e07575060009150819050600e611eb4565b60c08701516000908152600760205260409020546060860135811115611e3857600080600a93509350935050611eb4565b60c0880151600090815260076020526040812054611e5a906060890135612d80565b905080600003611e765760008060009450945094505050611eb4565b808611611e835785611e85565b805b945084600003611ea15760008060009450945094505050611eb4565b611eaf8588604001356123e2565b935050505b9450945094915050565b600080600084602001511561209d57600186604001516002811115611ee557611ee5612e7e565b03611f495785516060870151865186516101008a0151611f0894939291906123fc565b9250600083600e811115611f1e57611f1e612e7e565b14611f2e5750600090508061225b565b856101000151611f3d906130ca565b61010087015190925090505b602086015160808601518551875160e08a01516040808a015190516304c8fca560e51b815260048101959095526001600160a01b039384166024860152918316604485015260648401526084830152600092839283929091169063991f94a09060a4016060604051808303816000875af1158015611fcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fef91906130e6565b91945092509050600081600f81111561200a5761200a612e7e565b146120295761201881612546565b60008095509550955050505061225b565b60028960400151600281111561204157612041612e7e565b0361209557885160608a015188518a5161205f9392919087876125b2565b9550600086600e81111561207557612075612e7e565b1461208a57506000935083925061225b915050565b828280965081955050505b505050612256565b6001866040015160028111156120b5576120b5612e7e565b036121185785516060870151855187516101008a01516120d894939291906123fc565b9250600083600e8111156120ee576120ee612e7e565b146120fe5750600090508061225b565b85610100015161210d906130ca565b610100870151925090505b602086015160808601518651865160e08a01516040808a015190516304c8fca560e51b815260048101959095526001600160a01b039384166024860152918316604485015260648401526084830152600092839283929091169063991f94a09060a4016060604051808303816000875af115801561219a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121be91906130e6565b91945092509050600081600f8111156121d9576121d9612e7e565b146121e75761201881612546565b6002896040015160028111156121ff576121ff612e7e565b0361225257885160608a01518951895161221d9392919087876125b2565b9550600086600e81111561223357612233612e7e565b1461224857506000935083925061225b915050565b9193509150829082905b5050505b600092505b93509350939050565b608082015160c084015160a085015184517ffb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e906122a460208701876129fd565b6122b661012088016101008901612f58565b6020808a015160e08c0151604080516001600160a01b039788168152969095169286019290925260ff90921684840152901515606084015290870135608083015260a082015260c00160405180910390a4505050565b61231581611868565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606114c5838360405180606001604052806027815260200161318560279139612877565b60008082600c81111561238657612386612e7e565b0361239357506000919050565b600482600c8111156123a7576123a7612e7e565b036123b457506002919050565b600282600c8111156123c8576123c8612e7e565b036123d557506003919050565b506001919050565b919050565b6000620f42406123f28385613123565b6114c59190613142565b600080866001600160a01b031663262709e68688866040518463ffffffff1660e01b815260040161242f9392919061307d565b60408051808303816000875af115801561244d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061247191906130a1565b91506000905081600c81111561248957612489612e7e565b1461249f5761249781612371565b91505061253d565b604051637de182c560e01b81526001600160a01b03881690637de182c5906124cf9087908a90889060040161307d565b60408051808303816000875af11580156124ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061251191906130a1565b91506000905081600c81111561252957612529612e7e565b146125375761249781612371565b60009150505b95945050505050565b60008082600f81111561255b5761255b612e7e565b0361256857506000919050565b600282600f81111561257c5761257c612e7e565b0361258957506005919050565b600382600f81111561259d5761259d612e7e565b036125aa57506006919050565b506004919050565b60008083131561266557604051637de182c560e01b81526000906001600160a01b03891690637de182c5906125ef9089908b90899060040161307d565b60408051808303816000875af115801561260d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061263191906130a1565b91506000905081600c81111561264957612649612e7e565b1461265f5761265781612371565b91505061286d565b50612712565b60008312156127125760006001600160a01b03881663262709e6878961268a886130ca565b6040518463ffffffff1660e01b81526004016126a89392919061307d565b60408051808303816000875af11580156126c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126ea91906130a1565b91506000905081600c81111561270257612702612e7e565b146127105761265781612371565b505b60008213156127bc57604051637de182c560e01b81526000906001600160a01b03891690637de182c59061274e9088908b90889060040161307d565b60408051808303816000875af115801561276c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061279091906130a1565b91506000905081600c8111156127a8576127a8612e7e565b146127b65761265781612371565b50612869565b60008212156128695760006001600160a01b03881663262709e686896127e1876130ca565b6040518463ffffffff1660e01b81526004016127ff9392919061307d565b60408051808303816000875af115801561281d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061284191906130a1565b91506000905081600c81111561285957612859612e7e565b146128675761265781612371565b505b5060005b9695505050505050565b60606001600160a01b0384163b6128df5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b6064820152608401610497565b600080856001600160a01b0316856040516128fa9190612f23565b600060405180830381855af49150503d8060008114612935576040519150601f19603f3d011682016040523d82523d6000602084013e61293a565b606091505b509150915061286d828286606083156129545750816114c5565b8251156129645782518084602001fd5b8160405162461bcd60e51b815260040161049791906129aa565b60005b83811015612999578181015183820152602001612981565b838111156119295750506000910152565b60208152600082518060208401526129c981604085016020870161297e565b601f01601f19169190910160400192915050565b6001600160a01b038116811461044c57600080fd5b80356123dd816129dd565b600060208284031215612a0f57600080fd5b81356114c5816129dd565b600060208284031215612a2c57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051610140810167ffffffffffffffff81118282101715612a6d57612a6d612a33565b60405290565b600082601f830112612a8457600080fd5b813567ffffffffffffffff80821115612a9f57612a9f612a33565b604051601f8301601f19908116603f01168101908282118183101715612ac757612ac7612a33565b81604052838152866020858801011115612ae057600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215612b1357600080fd5b8235612b1e816129dd565b9150602083013567ffffffffffffffff811115612b3a57600080fd5b612b4685828601612a73565b9150509250929050565b801515811461044c57600080fd5b80356123dd81612b50565b60008060408385031215612b7c57600080fd5b8235612b87816129dd565b91506020830135612b9781612b50565b809150509250929050565b600080600060408486031215612bb757600080fd5b833567ffffffffffffffff80821115612bcf57600080fd5b908501906101408288031215612be457600080fd5b90935060208501359080821115612bfa57600080fd5b818601915086601f830112612c0e57600080fd5b813581811115612c1d57600080fd5b8760208260051b8501011115612c3257600080fd5b6020830194508093505050509250925092565b600060808201868352602086818501526080604085015281865180845260a086019150828801935060005b81811015612c8c57845183529383019391830191600101612c70565b50508481036060860152855180825290820192508186019060005b81811015612cc357825185529383019391830191600101612ca7565b50929998505050505050505050565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b634e487b7160e01b600052601160045260246000fd5b600082821015612d9257612d92612d6a565b500390565b600060208284031215612da957600080fd5b81516114c5816129dd565b803560ff811681146123dd57600080fd5b60006101408236031215612dd857600080fd5b612de0612a49565b612de9836129f2565b8152612df760208401612b5e565b602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013567ffffffffffffffff811115612e4857600080fd5b612e5436828601612a73565b60e083015250610100612e68818501612db4565b9082015261012092830135928101929092525090565b634e487b7160e01b600052602160045260246000fd5b600f8110612eb257634e487b7160e01b600052602160045260246000fd5b9052565b828152604081016114c56020830184612e94565b600060208284031215612edc57600080fd5b8151600381106114c557600080fd5b600060208284031215612efd57600080fd5b81516114c581612b50565b8381526020810183905260608101611d9b6040830184612e94565b60008251612f3581846020870161297e565b9190910192915050565b600060208284031215612f5157600080fd5b5051919050565b600060208284031215612f6a57600080fd5b6114c582612db4565b6000808335601e19843603018112612f8a57600080fd5b83018035915067ffffffffffffffff821115612fa557600080fd5b602001915036819003821315612fba57600080fd5b9250929050565b634e487b7160e01b600052603260045260246000fd5b6000823561013e19833603018112612f3557600080fd5b60006020828403121561300057600080fd5b81356114c581612b50565b6000821982111561301e5761301e612d6a565b500190565b600080821280156001600160ff1b038490038513161561304557613045612d6a565b600160ff1b839003841281161561305e5761305e612d6a565b50500190565b60006001820161307657613076612d6a565b5060010190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b600080604083850312156130b457600080fd5b825191506020830151600d8110612b9757600080fd5b6000600160ff1b82016130df576130df612d6a565b5060000390565b6000806000606084860312156130fb57600080fd5b835192506020840151915060408401516010811061311857600080fd5b809150509250925092565b600081600019048311821515161561313d5761313d612d6a565b500290565b60008261315f57634e487b7160e01b600052601260045260246000fd5b50049056fe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a164736f6c634300080f000a",
}

// ExchangeABI is the input ABI used to generate the binding from.
// Deprecated: Use ExchangeMetaData.ABI instead.
var ExchangeABI = ExchangeMetaData.ABI

// ExchangeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExchangeMetaData.Bin instead.
var ExchangeBin = ExchangeMetaData.Bin

// DeployExchange deploys a new Ethereum contract, binding an instance of Exchange to it.
func DeployExchange(auth *bind.TransactOpts, backend bind.ContractBackend, _domain string, _chainId *big.Int) (common.Address, *types.Transaction, *Exchange, error) {
	parsed, err := ExchangeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExchangeBin), backend, _domain, _chainId)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Exchange{ExchangeCaller: ExchangeCaller{contract: contract}, ExchangeTransactor: ExchangeTransactor{contract: contract}, ExchangeFilterer: ExchangeFilterer{contract: contract}}, nil
}

// Exchange is an auto generated Go binding around an Ethereum contract.
type Exchange struct {
	ExchangeCaller     // Read-only binding to the contract
	ExchangeTransactor // Write-only binding to the contract
	ExchangeFilterer   // Log filterer for contract events
}

// ExchangeCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExchangeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExchangeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExchangeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExchangeSession struct {
	Contract     *Exchange         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ExchangeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExchangeCallerSession struct {
	Contract *ExchangeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// ExchangeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExchangeTransactorSession struct {
	Contract     *ExchangeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ExchangeRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExchangeRaw struct {
	Contract *Exchange // Generic contract binding to access the raw methods on
}

// ExchangeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExchangeCallerRaw struct {
	Contract *ExchangeCaller // Generic read-only contract binding to access the raw methods on
}

// ExchangeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExchangeTransactorRaw struct {
	Contract *ExchangeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExchange creates a new instance of Exchange, bound to a specific deployed contract.
func NewExchange(address common.Address, backend bind.ContractBackend) (*Exchange, error) {
	contract, err := bindExchange(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Exchange{ExchangeCaller: ExchangeCaller{contract: contract}, ExchangeTransactor: ExchangeTransactor{contract: contract}, ExchangeFilterer: ExchangeFilterer{contract: contract}}, nil
}

// NewExchangeCaller creates a new read-only instance of Exchange, bound to a specific deployed contract.
func NewExchangeCaller(address common.Address, caller bind.ContractCaller) (*ExchangeCaller, error) {
	contract, err := bindExchange(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExchangeCaller{contract: contract}, nil
}

// NewExchangeTransactor creates a new write-only instance of Exchange, bound to a specific deployed contract.
func NewExchangeTransactor(address common.Address, transactor bind.ContractTransactor) (*ExchangeTransactor, error) {
	contract, err := bindExchange(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExchangeTransactor{contract: contract}, nil
}

// NewExchangeFilterer creates a new log filterer instance of Exchange, bound to a specific deployed contract.
func NewExchangeFilterer(address common.Address, filterer bind.ContractFilterer) (*ExchangeFilterer, error) {
	contract, err := bindExchange(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExchangeFilterer{contract: contract}, nil
}

// bindExchange binds a generic wrapper to an already deployed contract.
func bindExchange(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ExchangeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Exchange *ExchangeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Exchange.Contract.ExchangeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Exchange *ExchangeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Exchange.Contract.ExchangeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Exchange *ExchangeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Exchange.Contract.ExchangeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Exchange *ExchangeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Exchange.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Exchange *ExchangeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Exchange.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Exchange *ExchangeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Exchange.Contract.contract.Transact(opts, method, params...)
}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeCaller) Accounts(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "accounts")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeSession) Accounts() (common.Address, error) {
	return _Exchange.Contract.Accounts(&_Exchange.CallOpts)
}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeCallerSession) Accounts() (common.Address, error) {
	return _Exchange.Contract.Accounts(&_Exchange.CallOpts)
}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeCaller) Authorities(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "authorities", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeSession) Authorities(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Authorities(&_Exchange.CallOpts, arg0)
}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeCallerSession) Authorities(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Authorities(&_Exchange.CallOpts, arg0)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeCaller) DomainSeparator(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "domainSeparator")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeSession) DomainSeparator() ([32]byte, error) {
	return _Exchange.Contract.DomainSeparator(&_Exchange.CallOpts)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeCallerSession) DomainSeparator() ([32]byte, error) {
	return _Exchange.Contract.DomainSeparator(&_Exchange.CallOpts)
}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeCaller) Fills(opts *bind.CallOpts, arg0 [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "fills", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeSession) Fills(arg0 [32]byte) (*big.Int, error) {
	return _Exchange.Contract.Fills(&_Exchange.CallOpts, arg0)
}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeCallerSession) Fills(arg0 [32]byte) (*big.Int, error) {
	return _Exchange.Contract.Fills(&_Exchange.CallOpts, arg0)
}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeCaller) Instruments(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "instruments")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeSession) Instruments() (common.Address, error) {
	return _Exchange.Contract.Instruments(&_Exchange.CallOpts)
}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeCallerSession) Instruments() (common.Address, error) {
	return _Exchange.Contract.Instruments(&_Exchange.CallOpts)
}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeCaller) Keepers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "keepers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeSession) Keepers(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Keepers(&_Exchange.CallOpts, arg0)
}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeCallerSession) Keepers(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Keepers(&_Exchange.CallOpts, arg0)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeSession) Name() (string, error) {
	return _Exchange.Contract.Name(&_Exchange.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeCallerSession) Name() (string, error) {
	return _Exchange.Contract.Name(&_Exchange.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeSession) Owner() (common.Address, error) {
	return _Exchange.Contract.Owner(&_Exchange.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeCallerSession) Owner() (common.Address, error) {
	return _Exchange.Contract.Owner(&_Exchange.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeSession) ProxiableUUID() ([32]byte, error) {
	return _Exchange.Contract.ProxiableUUID(&_Exchange.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeCallerSession) ProxiableUUID() ([32]byte, error) {
	return _Exchange.Contract.ProxiableUUID(&_Exchange.CallOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeTransactor) Initialize(opts *bind.TransactOpts, _owner common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "initialize", _owner)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeSession) Initialize(_owner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.Initialize(&_Exchange.TransactOpts, _owner)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeTransactorSession) Initialize(_owner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.Initialize(&_Exchange.TransactOpts, _owner)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeTransactor) SetAccounts(opts *bind.TransactOpts, _accounts common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setAccounts", _accounts)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeSession) SetAccounts(_accounts common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetAccounts(&_Exchange.TransactOpts, _accounts)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeTransactorSession) SetAccounts(_accounts common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetAccounts(&_Exchange.TransactOpts, _accounts)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeTransactor) SetInstruments(opts *bind.TransactOpts, _instruments common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setInstruments", _instruments)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeSession) SetInstruments(_instruments common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetInstruments(&_Exchange.TransactOpts, _instruments)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeTransactorSession) SetInstruments(_instruments common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetInstruments(&_Exchange.TransactOpts, _instruments)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeTransactor) SetOwner(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setOwner", newOwner)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeSession) SetOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetOwner(&_Exchange.TransactOpts, newOwner)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeTransactorSession) SetOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetOwner(&_Exchange.TransactOpts, newOwner)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeTransactor) Trade(opts *bind.TransactOpts, taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "trade", taker, makers)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeSession) Trade(taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.Contract.Trade(&_Exchange.TransactOpts, taker, makers)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeTransactorSession) Trade(taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.Contract.Trade(&_Exchange.TransactOpts, taker, makers)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeTransactor) UpdateAuthority(opts *bind.TransactOpts, authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "updateAuthority", authority, allowed)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeSession) UpdateAuthority(authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateAuthority(&_Exchange.TransactOpts, authority, allowed)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeTransactorSession) UpdateAuthority(authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateAuthority(&_Exchange.TransactOpts, authority, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeTransactor) UpdateKeeper(opts *bind.TransactOpts, keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "updateKeeper", keeper, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeSession) UpdateKeeper(keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateKeeper(&_Exchange.TransactOpts, keeper, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeTransactorSession) UpdateKeeper(keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateKeeper(&_Exchange.TransactOpts, keeper, allowed)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeTransactor) UpgradeTo(opts *bind.TransactOpts, newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "upgradeTo", newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeTo(&_Exchange.TransactOpts, newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeTransactorSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeTo(&_Exchange.TransactOpts, newImplementation)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeToAndCall(&_Exchange.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeToAndCall(&_Exchange.TransactOpts, newImplementation, data)
}

// ExchangeAccountsUpdatedIterator is returned from FilterAccountsUpdated and is used to iterate over the raw logs and unpacked data for AccountsUpdated events raised by the Exchange contract.
type ExchangeAccountsUpdatedIterator struct {
	Event *ExchangeAccountsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAccountsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAccountsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAccountsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAccountsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAccountsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAccountsUpdated represents a AccountsUpdated event raised by the Exchange contract.
type ExchangeAccountsUpdated struct {
	Accounts common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterAccountsUpdated is a free log retrieval operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) FilterAccountsUpdated(opts *bind.FilterOpts, accounts []common.Address) (*ExchangeAccountsUpdatedIterator, error) {

	var accountsRule []interface{}
	for _, accountsItem := range accounts {
		accountsRule = append(accountsRule, accountsItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AccountsUpdated", accountsRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeAccountsUpdatedIterator{contract: _Exchange.contract, event: "AccountsUpdated", logs: logs, sub: sub}, nil
}

// WatchAccountsUpdated is a free log subscription operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) WatchAccountsUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeAccountsUpdated, accounts []common.Address) (event.Subscription, error) {

	var accountsRule []interface{}
	for _, accountsItem := range accounts {
		accountsRule = append(accountsRule, accountsItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AccountsUpdated", accountsRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAccountsUpdated)
				if err := _Exchange.contract.UnpackLog(event, "AccountsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAccountsUpdated is a log parse operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) ParseAccountsUpdated(log types.Log) (*ExchangeAccountsUpdated, error) {
	event := new(ExchangeAccountsUpdated)
	if err := _Exchange.contract.UnpackLog(event, "AccountsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeAdminChangedIterator is returned from FilterAdminChanged and is used to iterate over the raw logs and unpacked data for AdminChanged events raised by the Exchange contract.
type ExchangeAdminChangedIterator struct {
	Event *ExchangeAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAdminChanged represents a AdminChanged event raised by the Exchange contract.
type ExchangeAdminChanged struct {
	PreviousAdmin common.Address
	NewAdmin      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterAdminChanged is a free log retrieval operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) FilterAdminChanged(opts *bind.FilterOpts) (*ExchangeAdminChangedIterator, error) {

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return &ExchangeAdminChangedIterator{contract: _Exchange.contract, event: "AdminChanged", logs: logs, sub: sub}, nil
}

// WatchAdminChanged is a free log subscription operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *ExchangeAdminChanged) (event.Subscription, error) {

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAdminChanged)
				if err := _Exchange.contract.UnpackLog(event, "AdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAdminChanged is a log parse operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) ParseAdminChanged(log types.Log) (*ExchangeAdminChanged, error) {
	event := new(ExchangeAdminChanged)
	if err := _Exchange.contract.UnpackLog(event, "AdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeAuthorityUpdatedIterator is returned from FilterAuthorityUpdated and is used to iterate over the raw logs and unpacked data for AuthorityUpdated events raised by the Exchange contract.
type ExchangeAuthorityUpdatedIterator struct {
	Event *ExchangeAuthorityUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAuthorityUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAuthorityUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAuthorityUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAuthorityUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAuthorityUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAuthorityUpdated represents a AuthorityUpdated event raised by the Exchange contract.
type ExchangeAuthorityUpdated struct {
	Authority common.Address
	Allowed   bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAuthorityUpdated is a free log retrieval operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) FilterAuthorityUpdated(opts *bind.FilterOpts, authority []common.Address, allowed []bool) (*ExchangeAuthorityUpdatedIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AuthorityUpdated", authorityRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeAuthorityUpdatedIterator{contract: _Exchange.contract, event: "AuthorityUpdated", logs: logs, sub: sub}, nil
}

// WatchAuthorityUpdated is a free log subscription operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) WatchAuthorityUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeAuthorityUpdated, authority []common.Address, allowed []bool) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AuthorityUpdated", authorityRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAuthorityUpdated)
				if err := _Exchange.contract.UnpackLog(event, "AuthorityUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAuthorityUpdated is a log parse operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) ParseAuthorityUpdated(log types.Log) (*ExchangeAuthorityUpdated, error) {
	event := new(ExchangeAuthorityUpdated)
	if err := _Exchange.contract.UnpackLog(event, "AuthorityUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeBeaconUpgradedIterator is returned from FilterBeaconUpgraded and is used to iterate over the raw logs and unpacked data for BeaconUpgraded events raised by the Exchange contract.
type ExchangeBeaconUpgradedIterator struct {
	Event *ExchangeBeaconUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeBeaconUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeBeaconUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeBeaconUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeBeaconUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeBeaconUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeBeaconUpgraded represents a BeaconUpgraded event raised by the Exchange contract.
type ExchangeBeaconUpgraded struct {
	Beacon common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBeaconUpgraded is a free log retrieval operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (*ExchangeBeaconUpgradedIterator, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeBeaconUpgradedIterator{contract: _Exchange.contract, event: "BeaconUpgraded", logs: logs, sub: sub}, nil
}

// WatchBeaconUpgraded is a free log subscription operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *ExchangeBeaconUpgraded, beacon []common.Address) (event.Subscription, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeBeaconUpgraded)
				if err := _Exchange.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBeaconUpgraded is a log parse operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) ParseBeaconUpgraded(log types.Log) (*ExchangeBeaconUpgraded, error) {
	event := new(ExchangeBeaconUpgraded)
	if err := _Exchange.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeFeeIterator is returned from FilterFee and is used to iterate over the raw logs and unpacked data for Fee events raised by the Exchange contract.
type ExchangeFeeIterator struct {
	Event *ExchangeFee // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeFeeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeFee)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeFee)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeFeeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeFeeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeFee represents a Fee event raised by the Exchange contract.
type ExchangeFee struct {
	Order   [32]byte
	Account common.Address
	Fee     *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterFee is a free log retrieval operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) FilterFee(opts *bind.FilterOpts, order [][32]byte, account []common.Address) (*ExchangeFeeIterator, error) {

	var orderRule []interface{}
	for _, orderItem := range order {
		orderRule = append(orderRule, orderItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Fee", orderRule, accountRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeFeeIterator{contract: _Exchange.contract, event: "Fee", logs: logs, sub: sub}, nil
}

// WatchFee is a free log subscription operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) WatchFee(opts *bind.WatchOpts, sink chan<- *ExchangeFee, order [][32]byte, account []common.Address) (event.Subscription, error) {

	var orderRule []interface{}
	for _, orderItem := range order {
		orderRule = append(orderRule, orderItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Fee", orderRule, accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeFee)
				if err := _Exchange.contract.UnpackLog(event, "Fee", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFee is a log parse operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) ParseFee(log types.Log) (*ExchangeFee, error) {
	event := new(ExchangeFee)
	if err := _Exchange.contract.UnpackLog(event, "Fee", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeFillIterator is returned from FilterFill and is used to iterate over the raw logs and unpacked data for Fill events raised by the Exchange contract.
type ExchangeFillIterator struct {
	Event *ExchangeFill // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeFillIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeFill)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeFill)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeFillIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeFillIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeFill represents a Fill event raised by the Exchange contract.
type ExchangeFill struct {
	TakerOrder [32]byte
	MakerOrder [32]byte
	Instrument *big.Int
	Taker      common.Address
	Maker      common.Address
	OrderMode  *big.Int
	IsBuy      bool
	Price      *big.Int
	Amount     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterFill is a free log retrieval operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) FilterFill(opts *bind.FilterOpts, takerOrder [][32]byte, makerOrder [][32]byte, instrument []*big.Int) (*ExchangeFillIterator, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var makerOrderRule []interface{}
	for _, makerOrderItem := range makerOrder {
		makerOrderRule = append(makerOrderRule, makerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Fill", takerOrderRule, makerOrderRule, instrumentRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeFillIterator{contract: _Exchange.contract, event: "Fill", logs: logs, sub: sub}, nil
}

// WatchFill is a free log subscription operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) WatchFill(opts *bind.WatchOpts, sink chan<- *ExchangeFill, takerOrder [][32]byte, makerOrder [][32]byte, instrument []*big.Int) (event.Subscription, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var makerOrderRule []interface{}
	for _, makerOrderItem := range makerOrder {
		makerOrderRule = append(makerOrderRule, makerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Fill", takerOrderRule, makerOrderRule, instrumentRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeFill)
				if err := _Exchange.contract.UnpackLog(event, "Fill", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFill is a log parse operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) ParseFill(log types.Log) (*ExchangeFill, error) {
	event := new(ExchangeFill)
	if err := _Exchange.contract.UnpackLog(event, "Fill", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeInstrumentsUpdatedIterator is returned from FilterInstrumentsUpdated and is used to iterate over the raw logs and unpacked data for InstrumentsUpdated events raised by the Exchange contract.
type ExchangeInstrumentsUpdatedIterator struct {
	Event *ExchangeInstrumentsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeInstrumentsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeInstrumentsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeInstrumentsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeInstrumentsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeInstrumentsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeInstrumentsUpdated represents a InstrumentsUpdated event raised by the Exchange contract.
type ExchangeInstrumentsUpdated struct {
	Instruments common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterInstrumentsUpdated is a free log retrieval operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) FilterInstrumentsUpdated(opts *bind.FilterOpts, instruments []common.Address) (*ExchangeInstrumentsUpdatedIterator, error) {

	var instrumentsRule []interface{}
	for _, instrumentsItem := range instruments {
		instrumentsRule = append(instrumentsRule, instrumentsItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "InstrumentsUpdated", instrumentsRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeInstrumentsUpdatedIterator{contract: _Exchange.contract, event: "InstrumentsUpdated", logs: logs, sub: sub}, nil
}

// WatchInstrumentsUpdated is a free log subscription operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) WatchInstrumentsUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeInstrumentsUpdated, instruments []common.Address) (event.Subscription, error) {

	var instrumentsRule []interface{}
	for _, instrumentsItem := range instruments {
		instrumentsRule = append(instrumentsRule, instrumentsItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "InstrumentsUpdated", instrumentsRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeInstrumentsUpdated)
				if err := _Exchange.contract.UnpackLog(event, "InstrumentsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInstrumentsUpdated is a log parse operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) ParseInstrumentsUpdated(log types.Log) (*ExchangeInstrumentsUpdated, error) {
	event := new(ExchangeInstrumentsUpdated)
	if err := _Exchange.contract.UnpackLog(event, "InstrumentsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeKeeperUpdatedIterator is returned from FilterKeeperUpdated and is used to iterate over the raw logs and unpacked data for KeeperUpdated events raised by the Exchange contract.
type ExchangeKeeperUpdatedIterator struct {
	Event *ExchangeKeeperUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeKeeperUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeKeeperUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeKeeperUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeKeeperUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeKeeperUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeKeeperUpdated represents a KeeperUpdated event raised by the Exchange contract.
type ExchangeKeeperUpdated struct {
	Keeper  common.Address
	Allowed bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterKeeperUpdated is a free log retrieval operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) FilterKeeperUpdated(opts *bind.FilterOpts, keeper []common.Address, allowed []bool) (*ExchangeKeeperUpdatedIterator, error) {

	var keeperRule []interface{}
	for _, keeperItem := range keeper {
		keeperRule = append(keeperRule, keeperItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "KeeperUpdated", keeperRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeKeeperUpdatedIterator{contract: _Exchange.contract, event: "KeeperUpdated", logs: logs, sub: sub}, nil
}

// WatchKeeperUpdated is a free log subscription operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) WatchKeeperUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeKeeperUpdated, keeper []common.Address, allowed []bool) (event.Subscription, error) {

	var keeperRule []interface{}
	for _, keeperItem := range keeper {
		keeperRule = append(keeperRule, keeperItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "KeeperUpdated", keeperRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeKeeperUpdated)
				if err := _Exchange.contract.UnpackLog(event, "KeeperUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeeperUpdated is a log parse operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) ParseKeeperUpdated(log types.Log) (*ExchangeKeeperUpdated, error) {
	event := new(ExchangeKeeperUpdated)
	if err := _Exchange.contract.UnpackLog(event, "KeeperUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeOwnerUpdatedIterator is returned from FilterOwnerUpdated and is used to iterate over the raw logs and unpacked data for OwnerUpdated events raised by the Exchange contract.
type ExchangeOwnerUpdatedIterator struct {
	Event *ExchangeOwnerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeOwnerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeOwnerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeOwnerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeOwnerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeOwnerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeOwnerUpdated represents a OwnerUpdated event raised by the Exchange contract.
type ExchangeOwnerUpdated struct {
	NewOwner common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOwnerUpdated is a free log retrieval operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) FilterOwnerUpdated(opts *bind.FilterOpts, newOwner []common.Address) (*ExchangeOwnerUpdatedIterator, error) {

	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "OwnerUpdated", newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeOwnerUpdatedIterator{contract: _Exchange.contract, event: "OwnerUpdated", logs: logs, sub: sub}, nil
}

// WatchOwnerUpdated is a free log subscription operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) WatchOwnerUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeOwnerUpdated, newOwner []common.Address) (event.Subscription, error) {

	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "OwnerUpdated", newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeOwnerUpdated)
				if err := _Exchange.contract.UnpackLog(event, "OwnerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnerUpdated is a log parse operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) ParseOwnerUpdated(log types.Log) (*ExchangeOwnerUpdated, error) {
	event := new(ExchangeOwnerUpdated)
	if err := _Exchange.contract.UnpackLog(event, "OwnerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeTradeIterator is returned from FilterTrade and is used to iterate over the raw logs and unpacked data for Trade events raised by the Exchange contract.
type ExchangeTradeIterator struct {
	Event *ExchangeTrade // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeTradeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeTrade)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeTrade)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeTradeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeTradeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeTrade represents a Trade event raised by the Exchange contract.
type ExchangeTrade struct {
	TakerOrder [32]byte
	Instrument *big.Int
	OrderMode  *big.Int
	Taker      common.Address
	IsBuy      bool
	Amount     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterTrade is a free log retrieval operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) FilterTrade(opts *bind.FilterOpts, takerOrder [][32]byte, instrument []*big.Int, orderMode []*big.Int) (*ExchangeTradeIterator, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}
	var orderModeRule []interface{}
	for _, orderModeItem := range orderMode {
		orderModeRule = append(orderModeRule, orderModeItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Trade", takerOrderRule, instrumentRule, orderModeRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeTradeIterator{contract: _Exchange.contract, event: "Trade", logs: logs, sub: sub}, nil
}

// WatchTrade is a free log subscription operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) WatchTrade(opts *bind.WatchOpts, sink chan<- *ExchangeTrade, takerOrder [][32]byte, instrument []*big.Int, orderMode []*big.Int) (event.Subscription, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}
	var orderModeRule []interface{}
	for _, orderModeItem := range orderMode {
		orderModeRule = append(orderModeRule, orderModeItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Trade", takerOrderRule, instrumentRule, orderModeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeTrade)
				if err := _Exchange.contract.UnpackLog(event, "Trade", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTrade is a log parse operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) ParseTrade(log types.Log) (*ExchangeTrade, error) {
	event := new(ExchangeTrade)
	if err := _Exchange.contract.UnpackLog(event, "Trade", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the Exchange contract.
type ExchangeUpgradedIterator struct {
	Event *ExchangeUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeUpgraded represents a Upgraded event raised by the Exchange contract.
type ExchangeUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*ExchangeUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeUpgradedIterator{contract: _Exchange.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *ExchangeUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeUpgraded)
				if err := _Exchange.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) ParseUpgraded(log types.Log) (*ExchangeUpgraded, error) {
	event := new(ExchangeUpgraded)
	if err := _Exchange.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeVersionInitializedIterator is returned from FilterVersionInitialized and is used to iterate over the raw logs and unpacked data for VersionInitialized events raised by the Exchange contract.
type ExchangeVersionInitializedIterator struct {
	Event *ExchangeVersionInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeVersionInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeVersionInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeVersionInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeVersionInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeVersionInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeVersionInitialized represents a VersionInitialized event raised by the Exchange contract.
type ExchangeVersionInitialized struct {
	NewVersion *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterVersionInitialized is a free log retrieval operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) FilterVersionInitialized(opts *bind.FilterOpts, newVersion []*big.Int) (*ExchangeVersionInitializedIterator, error) {

	var newVersionRule []interface{}
	for _, newVersionItem := range newVersion {
		newVersionRule = append(newVersionRule, newVersionItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "VersionInitialized", newVersionRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeVersionInitializedIterator{contract: _Exchange.contract, event: "VersionInitialized", logs: logs, sub: sub}, nil
}

// WatchVersionInitialized is a free log subscription operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) WatchVersionInitialized(opts *bind.WatchOpts, sink chan<- *ExchangeVersionInitialized, newVersion []*big.Int) (event.Subscription, error) {

	var newVersionRule []interface{}
	for _, newVersionItem := range newVersion {
		newVersionRule = append(newVersionRule, newVersionItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "VersionInitialized", newVersionRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeVersionInitialized)
				if err := _Exchange.contract.UnpackLog(event, "VersionInitialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVersionInitialized is a log parse operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) ParseVersionInitialized(log types.Log) (*ExchangeVersionInitialized, error) {
	event := new(ExchangeVersionInitialized)
	if err := _Exchange.contract.UnpackLog(event, "VersionInitialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
