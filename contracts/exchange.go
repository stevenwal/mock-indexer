// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OrdersOrder is an auto generated low-level Go binding around an user-defined struct.
type OrdersOrder struct {
	Maker      common.Address
	IsBuy      bool
	LimitPrice *big.Int
	Amount     *big.Int
	Instrument *big.Int
	Salt       *big.Int
	Fee        *big.Int
	Signature  []byte
	OrderMode  uint8
	Id         *big.Int
}

// ExchangeMetaData contains all meta data concerning the Exchange contract.
var ExchangeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_domain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Initialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFills\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"takerHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"makerHash\",\"type\":\"bytes32\"},{\"internalType\":\"enumExchangeInterface.RevertReason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidMakerOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"takerHash\",\"type\":\"bytes32\"},{\"internalType\":\"enumExchangeInterface.RevertReason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidTakerOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthority\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotKeeper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accounts\",\"type\":\"address\"}],\"name\":\"AccountsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"order\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"}],\"name\":\"Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"takerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"makerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Fill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instruments\",\"type\":\"address\"}],\"name\":\"InstrumentsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"KeeperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"takerOrder\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newVersion\",\"type\":\"uint256\"}],\"name\":\"VersionInitialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorities\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instruments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keepers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accounts\",\"type\":\"address\"}],\"name\":\"setAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_orders\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fills\",\"type\":\"uint256[]\"}],\"name\":\"setFills\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instruments\",\"type\":\"address\"}],\"name\":\"setInstruments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"orderMode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"structOrders.Order\",\"name\":\"taker\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instrument\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"orderMode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"structOrders.Order[]\",\"name\":\"makers\",\"type\":\"tuple[]\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerFill\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"takerPnL\",\"type\":\"int256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerFills\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[]\",\"name\":\"makerPnLs\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
	Bin: "0x60c0604052306080523480156200001557600080fd5b5060405162003699380380620036998339810160408190526200003891620001ae565b6200004f82826200005b60201b62000e9a1760201c565b60a052506200028e9050565b6040516c08a92a06e626488dedac2d2dc5609b1b60208201526b1cdd1c9a5b99c81b985b594b60a21b602d8201526e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b60398201526e1d5a5b9d0c8d4d8818da185a5b9259608a1b6048820152602960f81b60578201526000906058016040516020818303038152906040528051906020012083604051602001620000f2919062000270565b60408051601f198184030181528282528051602091820120908301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201526080810183905260a00160405160208183030381529060405280519060200120905092915050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620001985781810151838201526020016200017e565b83811115620001a8576000848401525b50505050565b60008060408385031215620001c257600080fd5b82516001600160401b0380821115620001da57600080fd5b818501915085601f830112620001ef57600080fd5b81518181111562000204576200020462000165565b604051601f8201601f19908116603f011681019083821181831017156200022f576200022f62000165565b816040528281528860208487010111156200024957600080fd5b6200025c8360208301602088016200017b565b602097909701519698969750505050505050565b60008251620002848184602087016200017b565b9190910192915050565b60805160a0516133bb620002de600039600081816103c201528181610ab201526116e3015260008181610484015281816104cd015281816105fc0152818161063c01526106cf01526133bb6000f3fe6080604052600436106101145760003560e01c806352d1902d116100a057806391223d691161006457806391223d6914610340578063c4d66de814610370578063d305787714610390578063f698da25146103b0578063fce52eae146103e457600080fd5b806352d1902d146102ab578063667e6715146102c057806368cd03f6146102e05780636cd22eaf146103005780638da5cb5b1461032057600080fd5b80632e463e92116100e75780632e463e92146101e05780633659cfe61461021857806336de454e146102385780633bbd64bc146102585780634f1ef2861461029857600080fd5b806306fdde0314610119578063082743821461016357806313af40351461018557806320158c44146101a5575b600080fd5b34801561012557600080fd5b5061014d6040518060400160405280600881526020016745786368616e676560c01b81525081565b60405161015a9190612b2d565b60405180910390f35b34801561016f57600080fd5b5061018361017e366004612b80565b610414565b005b34801561019157600080fd5b506101836101a0366004612b80565b610466565b3480156101b157600080fd5b506101d26101c0366004612b9d565b60076020526000908152604090205481565b60405190815260200161015a565b3480156101ec57600080fd5b50600654610200906001600160a01b031681565b6040516001600160a01b03909116815260200161015a565b34801561022457600080fd5b50610183610233366004612b80565b61047a565b34801561024457600080fd5b50610183610253366004612c02565b61055f565b34801561026457600080fd5b50610288610273366004612b80565b60046020526000908152604090205460ff1681565b604051901515815260200161015a565b6101836102a6366004612d3b565b6105f2565b3480156102b757600080fd5b506101d26106c2565b3480156102cc57600080fd5b506101836102db366004612b80565b610775565b3480156102ec57600080fd5b50600554610200906001600160a01b031681565b34801561030c57600080fd5b5061018361031b366004612da4565b6107c7565b34801561032c57600080fd5b50600054610200906001600160a01b031681565b34801561034c57600080fd5b5061028861035b366004612b80565b60036020526000908152604090205460ff1681565b34801561037c57600080fd5b5061018361038b366004612b80565b61084a565b34801561039c57600080fd5b506101836103ab366004612da4565b6108c2565b3480156103bc57600080fd5b506101d27f000000000000000000000000000000000000000000000000000000000000000081565b3480156103f057600080fd5b506104046103ff366004612ddd565b610945565b60405161015a9493929190612e4f565b61041c610fa3565b600580546001600160a01b0319166001600160a01b0383169081179091556040517fbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d90600090a250565b61046e610fa3565b61047781610fcf565b50565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036104cb5760405162461bcd60e51b81526004016104c290612edc565b60405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610514600080516020613368833981519152546001600160a01b031690565b6001600160a01b03161461053a5760405162461bcd60e51b81526004016104c290612f28565b6105438161103e565b6040805160008082526020820190925261047791839190611046565b610567610fa3565b8281146105875760405163765f123f60e11b815260040160405180910390fd5b60005b838110156105eb578282828181106105a4576105a4612f74565b90506020020135600760008787858181106105c1576105c1612f74565b90506020020135815260200190815260200160002081905550806105e490612fa0565b905061058a565b5050505050565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016300361063a5760405162461bcd60e51b81526004016104c290612edc565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610683600080516020613368833981519152546001600160a01b031690565b6001600160a01b0316146106a95760405162461bcd60e51b81526004016104c290612f28565b6106b28261103e565b6106be82826001611046565b5050565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146107625760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c000000000000000060648201526084016104c2565b5060008051602061336883398151915290565b61077d610fa3565b600680546001600160a01b0319166001600160a01b0383169081179091556040517f50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa90600090a250565b6107cf610fa3565b6001600160a01b0382166107f65760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b038216600081815260036020526040808220805460ff191685151590811790915590519092917fc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc91a35050565b60016108568180612fb9565b60015414610877576040516302ed543d60e51b815260040160405180910390fd5b806001036108855760016002555b61088e82610fcf565b600181905560405181907f7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d90600090a25050565b6108ca610fa3565b6001600160a01b0382166108f15760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b038216600081815260046020526040808220805460ff191685151590811790915590519092917f786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c0091a35050565b6000806060806109536111b6565b60408051610160810182526000818301819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101408201526005546001600160a01b03908116808352600654909116602080840191909152835163999b93af60e01b815293519293919263999b93af9260048082019392918290030181865afa1580156109f8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1c9190612fd0565b81606001906001600160a01b031690816001600160a01b03168152505080600001516001600160a01b031663158626f76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f9190612fd0565b6001600160a01b03166080820152610ae07f0000000000000000000000000000000000000000000000000000000000000000610ada8a612ffe565b906111df565b60a08201523360009081526004602052604090205460ff16610b1e578060a001516007604051636be134e360e01b81526004016104c29291906130ef565b60208101516040516322bbad0b60e01b815260808a013560048201526001600160a01b03909116906322bbad0b90602401602060405180830381865afa158015610b6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b909190613103565b81604001906002811115610ba657610ba66130b7565b90816002811115610bb957610bb96130b7565b905250600081604001516002811115610bd457610bd46130b7565b03610bfb578060a00151600d604051636be134e360e01b81526004016104c29291906130ef565b602081015160405163c7f9df8b60e01b815260808a013560048201526001600160a01b039091169063c7f9df8b90602401602060405180830381865afa158015610c49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6d9190613124565b15610c94578060a001516008604051636be134e360e01b81526004016104c29291906130ef565b610ca78160000151898360a001516114d7565b610ccd578060a001516009604051636be134e360e01b81526004016104c29291906130ef565b60a08101516000908152600760205260409020546060890135811115610d0f578160a00151600a604051636be134e360e01b81526004016104c29291906130ef565b610d1d8160608b0135612fb9565b6101208301528667ffffffffffffffff811115610d3c57610d3c612c6e565b604051908082528060200260200182016040528015610d65578160200160208202803683370190505b5093508667ffffffffffffffff811115610d8157610d81612c6e565b604051908082528060200260200182016040528015610daa578160200160208202803683370190505b50925050600080610dc8838b610dbf90612ffe565b8b8b8989611670565b9092509050600081600e811115610de157610de16130b7565b14610e35578260a001518203610e12578260a0015181604051636be134e360e01b81526004016104c29291906130ef565b8260a001518282604051631761c9a760e31b81526004016104c293929190613141565b89606001358361012001511115610e68578260a00151600b604051636be134e360e01b81526004016104c29291906130ef565b610120830151610e7c9060608c0135612fb9565b96508261014001519550505050600160028190555093509350935093565b6040516c08a92a06e626488dedac2d2dc5609b1b60208201526b1cdd1c9a5b99c81b985b594b60a21b602d8201526e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b60398201526e1d5a5b9d0c8d4d8818da185a5b9259608a1b6048820152602960f81b60578201526000906058016040516020818303038152906040528051906020012083604051602001610f2f919061315c565b60408051601f198184030181528282528051602091820120908301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201526080810183905260a0016040516020818303038152906040528051906020012090505b92915050565b6000546001600160a01b03163314610fcd576040516282b42960e81b815260040160405180910390fd5b565b6001600160a01b038116610ff65760405163d92e233d60e01b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b610477610fa3565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff161561107e5761107983611a54565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156110d8575060408051601f3d908101601f191682019092526110d591810190613178565b60015b61113b5760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b60648201526084016104c2565b60008051602061336883398151915281146111aa5760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b60648201526084016104c2565b50611079838383611af0565b6002546001146111d95760405163558a1e0360e11b815260040160405180910390fd5b60028055565b6000600160ff1683610100015160ff16036112c5576112be82604051602001611252906a08cdee4c6ca9ee4c8cae4560ab1b8152721d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d0b606a1b600b820152691d5a5b9d0c8d4d881a5960b21b601e820152602960f81b602882015260290190565b60408051601f1981840301815282825280516020918201206080808a01516101208b015193860192909252928401526060830152015b6040516020818303038152906040528051906020012061190160f01b600090815260029290925260229081526042822091905290565b9050610f9d565b600260ff1683610100015160ff160361139f576112be826040516020016113509070098d2e2ead2c8c2e8d2dedc9ee4c8cae45607b1b81526a189bdbdb081a5cd09d5e4b60aa1b6011820152721d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d0b606a1b601c820152691d5a5b9d0c8d4d881a5960b21b602f820152602960f81b6039820152603a0190565b6040516020818303038152906040528051906020012085602001518660800151876101200151604051602001611288949392919093845291151560208401526040830152606082015260800190565b6112be82604051602001611459906509ee4c8cae4560d31b81526d1859191c995cdcc81b585ad95c8b60921b60068201526a189bdbdb081a5cd09d5e4b60aa1b6014820152721d5a5b9d0c8d4d881b1a5b5a5d141c9a58d94b606a1b601f8201526e1d5a5b9d0c8d4d88185b5bdd5b9d0b608a1b60328201526c1d5a5b9d0c8d4d881cd85b1d0b609a1b6041820152711d5a5b9d0c8d4d881a5b9cdd1c9d5b595b9d60721b604e820152602960f81b606082015260610190565b6040516020818303038152906040528051906020012085600001518660200151876040015188606001518960a001518a6080015160405160200161128897969594939291909687526001600160a01b0395909516602087015292151560408601526060850191909152608084015260a083015260c082015260e00190565b6000806114e76020850185612b80565b6001600160a01b03161461166557600061150961012085016101008601613191565b60ff16036116525761151e60e08401846131ac565b905060000361152f57506000611669565b600061157c8361154260e08701876131ac565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611b1b92505050565b905061158b6020850185612b80565b6001600160a01b0316816001600160a01b0316036115ad576001915050611669565b6001600160a01b0385166362946d3b6115c96020870187612b80565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529084166024820152604401602060405180830381865afa158015611615573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116399190613124565b15611648576001915050611669565b6000915050611669565b6101208301351561166557506001611669565b5060005b9392505050565b600080600061168d898a60a001518a600001518b60c00151611c0a565b9050600081600e8111156116a3576116a36130b7565b146116b65760a089015192509050611a49565b60005b86811015611a3f578961012001516000036116de575050505060a0860151600a611a49565b61172f7f000000000000000000000000000000000000000000000000000000000000000089898481811061171457611714612f74565b905060200281019061172691906131f3565b610ada90612ffe565b60c08b015287878281811061174657611746612f74565b905060200281019061175891906131f3565b61176990604081019060200161320a565b15158960200151151503611787575050505060c0860151600c611a49565b87878281811061179957611799612f74565b90506020028101906117ab91906131f3565b608001358960800151146117c9575050505060c0860151600d611a49565b6117fd8a8a8a8a858181106117e0576117e0612f74565b90506020028101906117f291906131f3565b8d6101200151611f5b565b6101008d019190915260e08c01919091529150600082600e811115611824576118246130b7565b14611838575060c089015192509050611a49565b60e08a015160a08b015160009081526007602052604081208054909190611860908490613227565b909155505060e08a015160c08b01516000908152600760205260408120805490919061188d908490613227565b909155505060e08a01516101208b0180516118a9908390612fb9565b90525060e08a015186518790839081106118c5576118c5612f74565b602002602001018181525050600061190a8b8b8b8b868181106118ea576118ea612f74565b90506020028101906118fc91906131f3565b61190590612ffe565b612041565b88858151811061191c5761191c612f74565b60209081029190910101529093509050600083600e811115611940576119406130b7565b1461195557505060c089015192509050611a49565b808b61014001818151611968919061323f565b90525060c08b01516119d5908c908b8b8681811061198857611988612f74565b905060200281019061199a91906131f3565b6119a8906020810190612b80565b8c8c878181106119ba576119ba612f74565b90506020028101906119cc91906131f3565b60c00135611c0a565b9250600083600e8111156119eb576119eb6130b7565b14611a0057505060c089015192509050611a49565b611a2e8b8b8b8b86818110611a1757611a17612f74565b9050602002810190611a2991906131f3565b6123e7565b50611a3881612fa0565b90506116b9565b5060009250829150505b965096945050505050565b6001600160a01b0381163b611ac15760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016104c2565b60008051602061336883398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b611af98361248f565b600082511180611b065750805b1561107957611b1583836124cf565b50505050565b6000806000808451604003611b4d57505050602082015160408301516001600160ff1b0381169060ff1c601b01611ba2565b8451604103611b965750505060208201516040830151606084015160001a601b8114801590611b8057508060ff16601c14155b15611b915760009350505050610f9d565b611ba2565b60009350505050610f9d565b60408051600081526020810180835288905260ff831691810191909152606081018490526080810183905260019060a0016020604051602081039080840390855afa158015611bf5573d6000803e3d6000fd5b5050604051601f190151979650505050505050565b600080821315611da8578451606086015160405163131384f360e11b81526000926001600160a01b03169163262709e691611c4b9188918890600401613280565b60408051808303816000875af1158015611c69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c8d91906132a4565b91506000905081600d811115611ca557611ca56130b7565b14611cbb57611cb3816124f4565b915050611f53565b855160808701516060880151604051637de182c560e01b81526001600160a01b0390931692637de182c592611cf69290918890600401613280565b60408051808303816000875af1158015611d14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d3891906132a4565b91506000905081600d811115611d5057611d506130b7565b14611d5e57611cb3816124f4565b836001600160a01b0316857fb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec85604051611d9a91815260200190565b60405180910390a350611f4f565b6000821215611f4f57600085600001516001600160a01b031663262709e68760800151886060015186611dda906132cd565b6040518463ffffffff1660e01b8152600401611df893929190613280565b60408051808303816000875af1158015611e16573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e3a91906132a4565b91506000905081600d811115611e5257611e526130b7565b14611e6057611cb3816124f4565b85600001516001600160a01b0316637de182c585886060015186611e83906132cd565b6040518463ffffffff1660e01b8152600401611ea193929190613280565b60408051808303816000875af1158015611ebf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ee391906132a4565b91506000905081600d811115611efb57611efb6130b7565b14611f0957611cb3816124f4565b836001600160a01b0316857fb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec85604051611f4591815260200190565b60405180910390a3505b5060005b949350505050565b6000806000611f738760000151868960c001516114d7565b611f865750600091508190506009612037565b8560200151611f9f578460400135866040015111611fab565b84604001358660400151105b15611fbf575060009150819050600e612037565b60c087015160009081526007602052604090205460608601358110611fef57600080600a93509350935050612037565b60c0880151600090815260076020526040812054612011906060890135612fb9565b90508086116120205785612022565b805b9450612032858860400135612565565b935050505b9450945094915050565b600080600084602001511561222057600186604001516002811115612068576120686130b7565b036120cc5785516060870151865186516101008a015161208b949392919061257f565b9250600083600e8111156120a1576120a16130b7565b146120b1575060009050806123de565b8561010001516120c0906132cd565b61010087015190925090505b602086015160808601518551875160e08a01516040808a015190516304c8fca560e51b815260048101959095526001600160a01b039384166024860152918316604485015260648401526084830152600092839283929091169063991f94a09060a4016060604051808303816000875af115801561214e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061217291906132e9565b91945092509050600081601181111561218d5761218d6130b7565b146121ac5761219b816126c9565b6000809550955095505050506123de565b6002896040015160028111156121c4576121c46130b7565b0361221857885160608a015188518a516121e2939291908787612735565b9550600086600e8111156121f8576121f86130b7565b1461220d5750600093508392506123de915050565b828280965081955050505b5050506123d9565b600186604001516002811115612238576122386130b7565b0361229b5785516060870151855187516101008a015161225b949392919061257f565b9250600083600e811115612271576122716130b7565b14612281575060009050806123de565b856101000151612290906132cd565b610100870151925090505b602086015160808601518651865160e08a01516040808a015190516304c8fca560e51b815260048101959095526001600160a01b039384166024860152918316604485015260648401526084830152600092839283929091169063991f94a09060a4016060604051808303816000875af115801561231d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061234191906132e9565b91945092509050600081601181111561235c5761235c6130b7565b1461236a5761219b816126c9565b600289604001516002811115612382576123826130b7565b036123d557885160608a0151895189516123a0939291908787612735565b9550600086600e8111156123b6576123b66130b7565b146123cb5750600093508392506123de915050565b9193509150829082905b5050505b600092505b93509350939050565b608082015160c084015160a085015184517ffb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e906124276020870187612b80565b61243961012088016101008901613191565b6020808a015160e08c0151604080516001600160a01b039788168152969095169286019290925260ff90921684840152901515606084015290870135608083015260a082015260c00160405180910390a4505050565b61249881611a54565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606116698383604051806060016040528060278152602001613388602791396129fa565b60008082600d811115612509576125096130b7565b0361251657506000919050565b600482600d81111561252a5761252a6130b7565b0361253757506002919050565b600282600d81111561254b5761254b6130b7565b0361255857506003919050565b506001919050565b919050565b6000620f42406125758385613326565b6116699190613345565b600080866001600160a01b031663262709e68688866040518463ffffffff1660e01b81526004016125b293929190613280565b60408051808303816000875af11580156125d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125f491906132a4565b91506000905081600d81111561260c5761260c6130b7565b146126225761261a816124f4565b9150506126c0565b604051637de182c560e01b81526001600160a01b03881690637de182c5906126529087908a908890600401613280565b60408051808303816000875af1158015612670573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269491906132a4565b91506000905081600d8111156126ac576126ac6130b7565b146126ba5761261a816124f4565b60009150505b95945050505050565b6000808260118111156126de576126de6130b7565b036126eb57506000919050565b60028260118111156126ff576126ff6130b7565b0361270c57506005919050565b6003826011811115612720576127206130b7565b0361272d57506006919050565b506004919050565b6000808313156127e857604051637de182c560e01b81526000906001600160a01b03891690637de182c5906127729089908b908990600401613280565b60408051808303816000875af1158015612790573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127b491906132a4565b91506000905081600d8111156127cc576127cc6130b7565b146127e2576127da816124f4565b9150506129f0565b50612895565b60008312156128955760006001600160a01b03881663262709e6878961280d886132cd565b6040518463ffffffff1660e01b815260040161282b93929190613280565b60408051808303816000875af1158015612849573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061286d91906132a4565b91506000905081600d811115612885576128856130b7565b14612893576127da816124f4565b505b600082131561293f57604051637de182c560e01b81526000906001600160a01b03891690637de182c5906128d19088908b908890600401613280565b60408051808303816000875af11580156128ef573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061291391906132a4565b91506000905081600d81111561292b5761292b6130b7565b14612939576127da816124f4565b506129ec565b60008212156129ec5760006001600160a01b03881663262709e68689612964876132cd565b6040518463ffffffff1660e01b815260040161298293929190613280565b60408051808303816000875af11580156129a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129c491906132a4565b91506000905081600d8111156129dc576129dc6130b7565b146129ea576127da816124f4565b505b5060005b9695505050505050565b60606001600160a01b0384163b612a625760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016104c2565b600080856001600160a01b031685604051612a7d919061315c565b600060405180830381855af49150503d8060008114612ab8576040519150601f19603f3d011682016040523d82523d6000602084013e612abd565b606091505b50915091506129f082828660608315612ad7575081611669565b825115612ae75782518084602001fd5b8160405162461bcd60e51b81526004016104c29190612b2d565b60005b83811015612b1c578181015183820152602001612b04565b83811115611b155750506000910152565b6020815260008251806020840152612b4c816040850160208701612b01565b601f01601f19169190910160400192915050565b6001600160a01b038116811461047757600080fd5b803561256081612b60565b600060208284031215612b9257600080fd5b813561166981612b60565b600060208284031215612baf57600080fd5b5035919050565b60008083601f840112612bc857600080fd5b50813567ffffffffffffffff811115612be057600080fd5b6020830191508360208260051b8501011115612bfb57600080fd5b9250929050565b60008060008060408587031215612c1857600080fd5b843567ffffffffffffffff80821115612c3057600080fd5b612c3c88838901612bb6565b90965094506020870135915080821115612c5557600080fd5b50612c6287828801612bb6565b95989497509550505050565b634e487b7160e01b600052604160045260246000fd5b604051610140810167ffffffffffffffff81118282101715612ca857612ca8612c6e565b60405290565b600082601f830112612cbf57600080fd5b813567ffffffffffffffff80821115612cda57612cda612c6e565b604051601f8301601f19908116603f01168101908282118183101715612d0257612d02612c6e565b81604052838152866020858801011115612d1b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215612d4e57600080fd5b8235612d5981612b60565b9150602083013567ffffffffffffffff811115612d7557600080fd5b612d8185828601612cae565b9150509250929050565b801515811461047757600080fd5b803561256081612d8b565b60008060408385031215612db757600080fd5b8235612dc281612b60565b91506020830135612dd281612d8b565b809150509250929050565b600080600060408486031215612df257600080fd5b833567ffffffffffffffff80821115612e0a57600080fd5b908501906101408288031215612e1f57600080fd5b90935060208501359080821115612e3557600080fd5b50612e4286828701612bb6565b9497909650939450505050565b600060808201868352602086818501526080604085015281865180845260a086019150828801935060005b81811015612e9657845183529383019391830191600101612e7a565b50508481036060860152855180825290820192508186019060005b81811015612ecd57825185529383019391830191600101612eb1565b50929998505050505050505050565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201612fb257612fb2612f8a565b5060010190565b600082821015612fcb57612fcb612f8a565b500390565b600060208284031215612fe257600080fd5b815161166981612b60565b803560ff8116811461256057600080fd5b6000610140823603121561301157600080fd5b613019612c84565b61302283612b75565b815261303060208401612d99565b602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013567ffffffffffffffff81111561308157600080fd5b61308d36828601612cae565b60e0830152506101006130a1818501612fed565b9082015261012092830135928101929092525090565b634e487b7160e01b600052602160045260246000fd5b600f81106130eb57634e487b7160e01b600052602160045260246000fd5b9052565b8281526040810161166960208301846130cd565b60006020828403121561311557600080fd5b81516003811061166957600080fd5b60006020828403121561313657600080fd5b815161166981612d8b565b8381526020810183905260608101611f5360408301846130cd565b6000825161316e818460208701612b01565b9190910192915050565b60006020828403121561318a57600080fd5b5051919050565b6000602082840312156131a357600080fd5b61166982612fed565b6000808335601e198436030181126131c357600080fd5b83018035915067ffffffffffffffff8211156131de57600080fd5b602001915036819003821315612bfb57600080fd5b6000823561013e1983360301811261316e57600080fd5b60006020828403121561321c57600080fd5b813561166981612d8b565b6000821982111561323a5761323a612f8a565b500190565b600080821280156001600160ff1b038490038513161561326157613261612f8a565b600160ff1b839003841281161561327a5761327a612f8a565b50500190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b600080604083850312156132b757600080fd5b825191506020830151600e8110612dd257600080fd5b6000600160ff1b82016132e2576132e2612f8a565b5060000390565b6000806000606084860312156132fe57600080fd5b835192506020840151915060408401516012811061331b57600080fd5b809150509250925092565b600081600019048311821515161561334057613340612f8a565b500290565b60008261336257634e487b7160e01b600052601260045260246000fd5b50049056fe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a164736f6c634300080f000a",
}

// ExchangeABI is the input ABI used to generate the binding from.
// Deprecated: Use ExchangeMetaData.ABI instead.
var ExchangeABI = ExchangeMetaData.ABI

// ExchangeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExchangeMetaData.Bin instead.
var ExchangeBin = ExchangeMetaData.Bin

// DeployExchange deploys a new Ethereum contract, binding an instance of Exchange to it.
func DeployExchange(auth *bind.TransactOpts, backend bind.ContractBackend, _domain string, _chainId *big.Int) (common.Address, *types.Transaction, *Exchange, error) {
	parsed, err := ExchangeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExchangeBin), backend, _domain, _chainId)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Exchange{ExchangeCaller: ExchangeCaller{contract: contract}, ExchangeTransactor: ExchangeTransactor{contract: contract}, ExchangeFilterer: ExchangeFilterer{contract: contract}}, nil
}

// Exchange is an auto generated Go binding around an Ethereum contract.
type Exchange struct {
	ExchangeCaller     // Read-only binding to the contract
	ExchangeTransactor // Write-only binding to the contract
	ExchangeFilterer   // Log filterer for contract events
}

// ExchangeCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExchangeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExchangeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExchangeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExchangeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExchangeSession struct {
	Contract     *Exchange         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ExchangeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExchangeCallerSession struct {
	Contract *ExchangeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// ExchangeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExchangeTransactorSession struct {
	Contract     *ExchangeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ExchangeRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExchangeRaw struct {
	Contract *Exchange // Generic contract binding to access the raw methods on
}

// ExchangeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExchangeCallerRaw struct {
	Contract *ExchangeCaller // Generic read-only contract binding to access the raw methods on
}

// ExchangeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExchangeTransactorRaw struct {
	Contract *ExchangeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExchange creates a new instance of Exchange, bound to a specific deployed contract.
func NewExchange(address common.Address, backend bind.ContractBackend) (*Exchange, error) {
	contract, err := bindExchange(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Exchange{ExchangeCaller: ExchangeCaller{contract: contract}, ExchangeTransactor: ExchangeTransactor{contract: contract}, ExchangeFilterer: ExchangeFilterer{contract: contract}}, nil
}

// NewExchangeCaller creates a new read-only instance of Exchange, bound to a specific deployed contract.
func NewExchangeCaller(address common.Address, caller bind.ContractCaller) (*ExchangeCaller, error) {
	contract, err := bindExchange(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExchangeCaller{contract: contract}, nil
}

// NewExchangeTransactor creates a new write-only instance of Exchange, bound to a specific deployed contract.
func NewExchangeTransactor(address common.Address, transactor bind.ContractTransactor) (*ExchangeTransactor, error) {
	contract, err := bindExchange(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExchangeTransactor{contract: contract}, nil
}

// NewExchangeFilterer creates a new log filterer instance of Exchange, bound to a specific deployed contract.
func NewExchangeFilterer(address common.Address, filterer bind.ContractFilterer) (*ExchangeFilterer, error) {
	contract, err := bindExchange(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExchangeFilterer{contract: contract}, nil
}

// bindExchange binds a generic wrapper to an already deployed contract.
func bindExchange(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ExchangeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Exchange *ExchangeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Exchange.Contract.ExchangeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Exchange *ExchangeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Exchange.Contract.ExchangeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Exchange *ExchangeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Exchange.Contract.ExchangeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Exchange *ExchangeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Exchange.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Exchange *ExchangeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Exchange.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Exchange *ExchangeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Exchange.Contract.contract.Transact(opts, method, params...)
}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeCaller) Accounts(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "accounts")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeSession) Accounts() (common.Address, error) {
	return _Exchange.Contract.Accounts(&_Exchange.CallOpts)
}

// Accounts is a free data retrieval call binding the contract method 0x68cd03f6.
//
// Solidity: function accounts() view returns(address)
func (_Exchange *ExchangeCallerSession) Accounts() (common.Address, error) {
	return _Exchange.Contract.Accounts(&_Exchange.CallOpts)
}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeCaller) Authorities(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "authorities", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeSession) Authorities(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Authorities(&_Exchange.CallOpts, arg0)
}

// Authorities is a free data retrieval call binding the contract method 0x91223d69.
//
// Solidity: function authorities(address ) view returns(bool)
func (_Exchange *ExchangeCallerSession) Authorities(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Authorities(&_Exchange.CallOpts, arg0)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeCaller) DomainSeparator(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "domainSeparator")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeSession) DomainSeparator() ([32]byte, error) {
	return _Exchange.Contract.DomainSeparator(&_Exchange.CallOpts)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Exchange *ExchangeCallerSession) DomainSeparator() ([32]byte, error) {
	return _Exchange.Contract.DomainSeparator(&_Exchange.CallOpts)
}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeCaller) Fills(opts *bind.CallOpts, arg0 [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "fills", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeSession) Fills(arg0 [32]byte) (*big.Int, error) {
	return _Exchange.Contract.Fills(&_Exchange.CallOpts, arg0)
}

// Fills is a free data retrieval call binding the contract method 0x20158c44.
//
// Solidity: function fills(bytes32 ) view returns(uint256)
func (_Exchange *ExchangeCallerSession) Fills(arg0 [32]byte) (*big.Int, error) {
	return _Exchange.Contract.Fills(&_Exchange.CallOpts, arg0)
}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeCaller) Instruments(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "instruments")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeSession) Instruments() (common.Address, error) {
	return _Exchange.Contract.Instruments(&_Exchange.CallOpts)
}

// Instruments is a free data retrieval call binding the contract method 0x2e463e92.
//
// Solidity: function instruments() view returns(address)
func (_Exchange *ExchangeCallerSession) Instruments() (common.Address, error) {
	return _Exchange.Contract.Instruments(&_Exchange.CallOpts)
}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeCaller) Keepers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "keepers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeSession) Keepers(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Keepers(&_Exchange.CallOpts, arg0)
}

// Keepers is a free data retrieval call binding the contract method 0x3bbd64bc.
//
// Solidity: function keepers(address ) view returns(bool)
func (_Exchange *ExchangeCallerSession) Keepers(arg0 common.Address) (bool, error) {
	return _Exchange.Contract.Keepers(&_Exchange.CallOpts, arg0)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeSession) Name() (string, error) {
	return _Exchange.Contract.Name(&_Exchange.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Exchange *ExchangeCallerSession) Name() (string, error) {
	return _Exchange.Contract.Name(&_Exchange.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeSession) Owner() (common.Address, error) {
	return _Exchange.Contract.Owner(&_Exchange.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Exchange *ExchangeCallerSession) Owner() (common.Address, error) {
	return _Exchange.Contract.Owner(&_Exchange.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Exchange.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeSession) ProxiableUUID() ([32]byte, error) {
	return _Exchange.Contract.ProxiableUUID(&_Exchange.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Exchange *ExchangeCallerSession) ProxiableUUID() ([32]byte, error) {
	return _Exchange.Contract.ProxiableUUID(&_Exchange.CallOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeTransactor) Initialize(opts *bind.TransactOpts, _owner common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "initialize", _owner)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeSession) Initialize(_owner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.Initialize(&_Exchange.TransactOpts, _owner)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _owner) returns()
func (_Exchange *ExchangeTransactorSession) Initialize(_owner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.Initialize(&_Exchange.TransactOpts, _owner)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeTransactor) SetAccounts(opts *bind.TransactOpts, _accounts common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setAccounts", _accounts)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeSession) SetAccounts(_accounts common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetAccounts(&_Exchange.TransactOpts, _accounts)
}

// SetAccounts is a paid mutator transaction binding the contract method 0x08274382.
//
// Solidity: function setAccounts(address _accounts) returns()
func (_Exchange *ExchangeTransactorSession) SetAccounts(_accounts common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetAccounts(&_Exchange.TransactOpts, _accounts)
}

// SetFills is a paid mutator transaction binding the contract method 0x36de454e.
//
// Solidity: function setFills(bytes32[] _orders, uint256[] _fills) returns()
func (_Exchange *ExchangeTransactor) SetFills(opts *bind.TransactOpts, _orders [][32]byte, _fills []*big.Int) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setFills", _orders, _fills)
}

// SetFills is a paid mutator transaction binding the contract method 0x36de454e.
//
// Solidity: function setFills(bytes32[] _orders, uint256[] _fills) returns()
func (_Exchange *ExchangeSession) SetFills(_orders [][32]byte, _fills []*big.Int) (*types.Transaction, error) {
	return _Exchange.Contract.SetFills(&_Exchange.TransactOpts, _orders, _fills)
}

// SetFills is a paid mutator transaction binding the contract method 0x36de454e.
//
// Solidity: function setFills(bytes32[] _orders, uint256[] _fills) returns()
func (_Exchange *ExchangeTransactorSession) SetFills(_orders [][32]byte, _fills []*big.Int) (*types.Transaction, error) {
	return _Exchange.Contract.SetFills(&_Exchange.TransactOpts, _orders, _fills)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeTransactor) SetInstruments(opts *bind.TransactOpts, _instruments common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setInstruments", _instruments)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeSession) SetInstruments(_instruments common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetInstruments(&_Exchange.TransactOpts, _instruments)
}

// SetInstruments is a paid mutator transaction binding the contract method 0x667e6715.
//
// Solidity: function setInstruments(address _instruments) returns()
func (_Exchange *ExchangeTransactorSession) SetInstruments(_instruments common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetInstruments(&_Exchange.TransactOpts, _instruments)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeTransactor) SetOwner(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "setOwner", newOwner)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeSession) SetOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetOwner(&_Exchange.TransactOpts, newOwner)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address newOwner) returns()
func (_Exchange *ExchangeTransactorSession) SetOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.SetOwner(&_Exchange.TransactOpts, newOwner)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeTransactor) Trade(opts *bind.TransactOpts, taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "trade", taker, makers)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeSession) Trade(taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.Contract.Trade(&_Exchange.TransactOpts, taker, makers)
}

// Trade is a paid mutator transaction binding the contract method 0xfce52eae.
//
// Solidity: function trade((address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256) taker, (address,bool,uint256,uint256,uint256,uint256,int256,bytes,uint8,uint256)[] makers) returns(uint256 takerFill, int256 takerPnL, uint256[] makerFills, int256[] makerPnLs)
func (_Exchange *ExchangeTransactorSession) Trade(taker OrdersOrder, makers []OrdersOrder) (*types.Transaction, error) {
	return _Exchange.Contract.Trade(&_Exchange.TransactOpts, taker, makers)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeTransactor) UpdateAuthority(opts *bind.TransactOpts, authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "updateAuthority", authority, allowed)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeSession) UpdateAuthority(authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateAuthority(&_Exchange.TransactOpts, authority, allowed)
}

// UpdateAuthority is a paid mutator transaction binding the contract method 0x6cd22eaf.
//
// Solidity: function updateAuthority(address authority, bool allowed) returns()
func (_Exchange *ExchangeTransactorSession) UpdateAuthority(authority common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateAuthority(&_Exchange.TransactOpts, authority, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeTransactor) UpdateKeeper(opts *bind.TransactOpts, keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "updateKeeper", keeper, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeSession) UpdateKeeper(keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateKeeper(&_Exchange.TransactOpts, keeper, allowed)
}

// UpdateKeeper is a paid mutator transaction binding the contract method 0xd3057877.
//
// Solidity: function updateKeeper(address keeper, bool allowed) returns()
func (_Exchange *ExchangeTransactorSession) UpdateKeeper(keeper common.Address, allowed bool) (*types.Transaction, error) {
	return _Exchange.Contract.UpdateKeeper(&_Exchange.TransactOpts, keeper, allowed)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeTransactor) UpgradeTo(opts *bind.TransactOpts, newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "upgradeTo", newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeTo(&_Exchange.TransactOpts, newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Exchange *ExchangeTransactorSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeTo(&_Exchange.TransactOpts, newImplementation)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeToAndCall(&_Exchange.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Exchange *ExchangeTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Exchange.Contract.UpgradeToAndCall(&_Exchange.TransactOpts, newImplementation, data)
}

// ExchangeAccountsUpdatedIterator is returned from FilterAccountsUpdated and is used to iterate over the raw logs and unpacked data for AccountsUpdated events raised by the Exchange contract.
type ExchangeAccountsUpdatedIterator struct {
	Event *ExchangeAccountsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAccountsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAccountsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAccountsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAccountsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAccountsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAccountsUpdated represents a AccountsUpdated event raised by the Exchange contract.
type ExchangeAccountsUpdated struct {
	Accounts common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterAccountsUpdated is a free log retrieval operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) FilterAccountsUpdated(opts *bind.FilterOpts, accounts []common.Address) (*ExchangeAccountsUpdatedIterator, error) {

	var accountsRule []interface{}
	for _, accountsItem := range accounts {
		accountsRule = append(accountsRule, accountsItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AccountsUpdated", accountsRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeAccountsUpdatedIterator{contract: _Exchange.contract, event: "AccountsUpdated", logs: logs, sub: sub}, nil
}

// WatchAccountsUpdated is a free log subscription operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) WatchAccountsUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeAccountsUpdated, accounts []common.Address) (event.Subscription, error) {

	var accountsRule []interface{}
	for _, accountsItem := range accounts {
		accountsRule = append(accountsRule, accountsItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AccountsUpdated", accountsRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAccountsUpdated)
				if err := _Exchange.contract.UnpackLog(event, "AccountsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAccountsUpdated is a log parse operation binding the contract event 0xbecde7fe690c73ba54232f00eb06c31464f65b45aff18984febaa80df22dcb8d.
//
// Solidity: event AccountsUpdated(address indexed accounts)
func (_Exchange *ExchangeFilterer) ParseAccountsUpdated(log types.Log) (*ExchangeAccountsUpdated, error) {
	event := new(ExchangeAccountsUpdated)
	if err := _Exchange.contract.UnpackLog(event, "AccountsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeAdminChangedIterator is returned from FilterAdminChanged and is used to iterate over the raw logs and unpacked data for AdminChanged events raised by the Exchange contract.
type ExchangeAdminChangedIterator struct {
	Event *ExchangeAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAdminChanged represents a AdminChanged event raised by the Exchange contract.
type ExchangeAdminChanged struct {
	PreviousAdmin common.Address
	NewAdmin      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterAdminChanged is a free log retrieval operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) FilterAdminChanged(opts *bind.FilterOpts) (*ExchangeAdminChangedIterator, error) {

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return &ExchangeAdminChangedIterator{contract: _Exchange.contract, event: "AdminChanged", logs: logs, sub: sub}, nil
}

// WatchAdminChanged is a free log subscription operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *ExchangeAdminChanged) (event.Subscription, error) {

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAdminChanged)
				if err := _Exchange.contract.UnpackLog(event, "AdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAdminChanged is a log parse operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Exchange *ExchangeFilterer) ParseAdminChanged(log types.Log) (*ExchangeAdminChanged, error) {
	event := new(ExchangeAdminChanged)
	if err := _Exchange.contract.UnpackLog(event, "AdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeAuthorityUpdatedIterator is returned from FilterAuthorityUpdated and is used to iterate over the raw logs and unpacked data for AuthorityUpdated events raised by the Exchange contract.
type ExchangeAuthorityUpdatedIterator struct {
	Event *ExchangeAuthorityUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeAuthorityUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeAuthorityUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeAuthorityUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeAuthorityUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeAuthorityUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeAuthorityUpdated represents a AuthorityUpdated event raised by the Exchange contract.
type ExchangeAuthorityUpdated struct {
	Authority common.Address
	Allowed   bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAuthorityUpdated is a free log retrieval operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) FilterAuthorityUpdated(opts *bind.FilterOpts, authority []common.Address, allowed []bool) (*ExchangeAuthorityUpdatedIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "AuthorityUpdated", authorityRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeAuthorityUpdatedIterator{contract: _Exchange.contract, event: "AuthorityUpdated", logs: logs, sub: sub}, nil
}

// WatchAuthorityUpdated is a free log subscription operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) WatchAuthorityUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeAuthorityUpdated, authority []common.Address, allowed []bool) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "AuthorityUpdated", authorityRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeAuthorityUpdated)
				if err := _Exchange.contract.UnpackLog(event, "AuthorityUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAuthorityUpdated is a log parse operation binding the contract event 0xc5238a63fa205f95e98807f6cbc91d2ad8555a2250075e47491f11d9c69db3bc.
//
// Solidity: event AuthorityUpdated(address indexed authority, bool indexed allowed)
func (_Exchange *ExchangeFilterer) ParseAuthorityUpdated(log types.Log) (*ExchangeAuthorityUpdated, error) {
	event := new(ExchangeAuthorityUpdated)
	if err := _Exchange.contract.UnpackLog(event, "AuthorityUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeBeaconUpgradedIterator is returned from FilterBeaconUpgraded and is used to iterate over the raw logs and unpacked data for BeaconUpgraded events raised by the Exchange contract.
type ExchangeBeaconUpgradedIterator struct {
	Event *ExchangeBeaconUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeBeaconUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeBeaconUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeBeaconUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeBeaconUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeBeaconUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeBeaconUpgraded represents a BeaconUpgraded event raised by the Exchange contract.
type ExchangeBeaconUpgraded struct {
	Beacon common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBeaconUpgraded is a free log retrieval operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (*ExchangeBeaconUpgradedIterator, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeBeaconUpgradedIterator{contract: _Exchange.contract, event: "BeaconUpgraded", logs: logs, sub: sub}, nil
}

// WatchBeaconUpgraded is a free log subscription operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *ExchangeBeaconUpgraded, beacon []common.Address) (event.Subscription, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeBeaconUpgraded)
				if err := _Exchange.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBeaconUpgraded is a log parse operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Exchange *ExchangeFilterer) ParseBeaconUpgraded(log types.Log) (*ExchangeBeaconUpgraded, error) {
	event := new(ExchangeBeaconUpgraded)
	if err := _Exchange.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeFeeIterator is returned from FilterFee and is used to iterate over the raw logs and unpacked data for Fee events raised by the Exchange contract.
type ExchangeFeeIterator struct {
	Event *ExchangeFee // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeFeeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeFee)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeFee)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeFeeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeFeeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeFee represents a Fee event raised by the Exchange contract.
type ExchangeFee struct {
	Order   [32]byte
	Account common.Address
	Fee     *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterFee is a free log retrieval operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) FilterFee(opts *bind.FilterOpts, order [][32]byte, account []common.Address) (*ExchangeFeeIterator, error) {

	var orderRule []interface{}
	for _, orderItem := range order {
		orderRule = append(orderRule, orderItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Fee", orderRule, accountRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeFeeIterator{contract: _Exchange.contract, event: "Fee", logs: logs, sub: sub}, nil
}

// WatchFee is a free log subscription operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) WatchFee(opts *bind.WatchOpts, sink chan<- *ExchangeFee, order [][32]byte, account []common.Address) (event.Subscription, error) {

	var orderRule []interface{}
	for _, orderItem := range order {
		orderRule = append(orderRule, orderItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Fee", orderRule, accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeFee)
				if err := _Exchange.contract.UnpackLog(event, "Fee", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFee is a log parse operation binding the contract event 0xb124cbc3422cb4f6eb9c89ce67b72f6699e9d526b5c348dde40b9b6d554de8ec.
//
// Solidity: event Fee(bytes32 indexed order, address indexed account, int256 fee)
func (_Exchange *ExchangeFilterer) ParseFee(log types.Log) (*ExchangeFee, error) {
	event := new(ExchangeFee)
	if err := _Exchange.contract.UnpackLog(event, "Fee", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeFillIterator is returned from FilterFill and is used to iterate over the raw logs and unpacked data for Fill events raised by the Exchange contract.
type ExchangeFillIterator struct {
	Event *ExchangeFill // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeFillIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeFill)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeFill)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeFillIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeFillIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeFill represents a Fill event raised by the Exchange contract.
type ExchangeFill struct {
	TakerOrder [32]byte
	MakerOrder [32]byte
	Instrument *big.Int
	Taker      common.Address
	Maker      common.Address
	OrderMode  *big.Int
	IsBuy      bool
	Price      *big.Int
	Amount     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterFill is a free log retrieval operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) FilterFill(opts *bind.FilterOpts, takerOrder [][32]byte, makerOrder [][32]byte, instrument []*big.Int) (*ExchangeFillIterator, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var makerOrderRule []interface{}
	for _, makerOrderItem := range makerOrder {
		makerOrderRule = append(makerOrderRule, makerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Fill", takerOrderRule, makerOrderRule, instrumentRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeFillIterator{contract: _Exchange.contract, event: "Fill", logs: logs, sub: sub}, nil
}

// WatchFill is a free log subscription operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) WatchFill(opts *bind.WatchOpts, sink chan<- *ExchangeFill, takerOrder [][32]byte, makerOrder [][32]byte, instrument []*big.Int) (event.Subscription, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var makerOrderRule []interface{}
	for _, makerOrderItem := range makerOrder {
		makerOrderRule = append(makerOrderRule, makerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Fill", takerOrderRule, makerOrderRule, instrumentRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeFill)
				if err := _Exchange.contract.UnpackLog(event, "Fill", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFill is a log parse operation binding the contract event 0xfb90ca9028db86acee1ea029b88ad48b17566596df4bd82b301e1ba839386b9e.
//
// Solidity: event Fill(bytes32 indexed takerOrder, bytes32 indexed makerOrder, uint256 indexed instrument, address taker, address maker, uint256 orderMode, bool isBuy, uint256 price, uint256 amount)
func (_Exchange *ExchangeFilterer) ParseFill(log types.Log) (*ExchangeFill, error) {
	event := new(ExchangeFill)
	if err := _Exchange.contract.UnpackLog(event, "Fill", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeInstrumentsUpdatedIterator is returned from FilterInstrumentsUpdated and is used to iterate over the raw logs and unpacked data for InstrumentsUpdated events raised by the Exchange contract.
type ExchangeInstrumentsUpdatedIterator struct {
	Event *ExchangeInstrumentsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeInstrumentsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeInstrumentsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeInstrumentsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeInstrumentsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeInstrumentsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeInstrumentsUpdated represents a InstrumentsUpdated event raised by the Exchange contract.
type ExchangeInstrumentsUpdated struct {
	Instruments common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterInstrumentsUpdated is a free log retrieval operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) FilterInstrumentsUpdated(opts *bind.FilterOpts, instruments []common.Address) (*ExchangeInstrumentsUpdatedIterator, error) {

	var instrumentsRule []interface{}
	for _, instrumentsItem := range instruments {
		instrumentsRule = append(instrumentsRule, instrumentsItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "InstrumentsUpdated", instrumentsRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeInstrumentsUpdatedIterator{contract: _Exchange.contract, event: "InstrumentsUpdated", logs: logs, sub: sub}, nil
}

// WatchInstrumentsUpdated is a free log subscription operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) WatchInstrumentsUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeInstrumentsUpdated, instruments []common.Address) (event.Subscription, error) {

	var instrumentsRule []interface{}
	for _, instrumentsItem := range instruments {
		instrumentsRule = append(instrumentsRule, instrumentsItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "InstrumentsUpdated", instrumentsRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeInstrumentsUpdated)
				if err := _Exchange.contract.UnpackLog(event, "InstrumentsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInstrumentsUpdated is a log parse operation binding the contract event 0x50eb8cf43b6ebfc7f9c82d966ed94d0d56e326150c0c770dfead0dcb8c02c8fa.
//
// Solidity: event InstrumentsUpdated(address indexed instruments)
func (_Exchange *ExchangeFilterer) ParseInstrumentsUpdated(log types.Log) (*ExchangeInstrumentsUpdated, error) {
	event := new(ExchangeInstrumentsUpdated)
	if err := _Exchange.contract.UnpackLog(event, "InstrumentsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeKeeperUpdatedIterator is returned from FilterKeeperUpdated and is used to iterate over the raw logs and unpacked data for KeeperUpdated events raised by the Exchange contract.
type ExchangeKeeperUpdatedIterator struct {
	Event *ExchangeKeeperUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeKeeperUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeKeeperUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeKeeperUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeKeeperUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeKeeperUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeKeeperUpdated represents a KeeperUpdated event raised by the Exchange contract.
type ExchangeKeeperUpdated struct {
	Keeper  common.Address
	Allowed bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterKeeperUpdated is a free log retrieval operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) FilterKeeperUpdated(opts *bind.FilterOpts, keeper []common.Address, allowed []bool) (*ExchangeKeeperUpdatedIterator, error) {

	var keeperRule []interface{}
	for _, keeperItem := range keeper {
		keeperRule = append(keeperRule, keeperItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "KeeperUpdated", keeperRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeKeeperUpdatedIterator{contract: _Exchange.contract, event: "KeeperUpdated", logs: logs, sub: sub}, nil
}

// WatchKeeperUpdated is a free log subscription operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) WatchKeeperUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeKeeperUpdated, keeper []common.Address, allowed []bool) (event.Subscription, error) {

	var keeperRule []interface{}
	for _, keeperItem := range keeper {
		keeperRule = append(keeperRule, keeperItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "KeeperUpdated", keeperRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeKeeperUpdated)
				if err := _Exchange.contract.UnpackLog(event, "KeeperUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeeperUpdated is a log parse operation binding the contract event 0x786c9db967bf0c6b16c7c91adae8a8c554b15a57d373fa2059607300f4616c00.
//
// Solidity: event KeeperUpdated(address indexed keeper, bool indexed allowed)
func (_Exchange *ExchangeFilterer) ParseKeeperUpdated(log types.Log) (*ExchangeKeeperUpdated, error) {
	event := new(ExchangeKeeperUpdated)
	if err := _Exchange.contract.UnpackLog(event, "KeeperUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeOwnerUpdatedIterator is returned from FilterOwnerUpdated and is used to iterate over the raw logs and unpacked data for OwnerUpdated events raised by the Exchange contract.
type ExchangeOwnerUpdatedIterator struct {
	Event *ExchangeOwnerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeOwnerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeOwnerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeOwnerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeOwnerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeOwnerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeOwnerUpdated represents a OwnerUpdated event raised by the Exchange contract.
type ExchangeOwnerUpdated struct {
	NewOwner common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOwnerUpdated is a free log retrieval operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) FilterOwnerUpdated(opts *bind.FilterOpts, newOwner []common.Address) (*ExchangeOwnerUpdatedIterator, error) {

	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "OwnerUpdated", newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeOwnerUpdatedIterator{contract: _Exchange.contract, event: "OwnerUpdated", logs: logs, sub: sub}, nil
}

// WatchOwnerUpdated is a free log subscription operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) WatchOwnerUpdated(opts *bind.WatchOpts, sink chan<- *ExchangeOwnerUpdated, newOwner []common.Address) (event.Subscription, error) {

	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "OwnerUpdated", newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeOwnerUpdated)
				if err := _Exchange.contract.UnpackLog(event, "OwnerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnerUpdated is a log parse operation binding the contract event 0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b.
//
// Solidity: event OwnerUpdated(address indexed newOwner)
func (_Exchange *ExchangeFilterer) ParseOwnerUpdated(log types.Log) (*ExchangeOwnerUpdated, error) {
	event := new(ExchangeOwnerUpdated)
	if err := _Exchange.contract.UnpackLog(event, "OwnerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeTradeIterator is returned from FilterTrade and is used to iterate over the raw logs and unpacked data for Trade events raised by the Exchange contract.
type ExchangeTradeIterator struct {
	Event *ExchangeTrade // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeTradeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeTrade)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeTrade)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeTradeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeTradeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeTrade represents a Trade event raised by the Exchange contract.
type ExchangeTrade struct {
	TakerOrder [32]byte
	Instrument *big.Int
	OrderMode  *big.Int
	Taker      common.Address
	IsBuy      bool
	Amount     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterTrade is a free log retrieval operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) FilterTrade(opts *bind.FilterOpts, takerOrder [][32]byte, instrument []*big.Int, orderMode []*big.Int) (*ExchangeTradeIterator, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}
	var orderModeRule []interface{}
	for _, orderModeItem := range orderMode {
		orderModeRule = append(orderModeRule, orderModeItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Trade", takerOrderRule, instrumentRule, orderModeRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeTradeIterator{contract: _Exchange.contract, event: "Trade", logs: logs, sub: sub}, nil
}

// WatchTrade is a free log subscription operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) WatchTrade(opts *bind.WatchOpts, sink chan<- *ExchangeTrade, takerOrder [][32]byte, instrument []*big.Int, orderMode []*big.Int) (event.Subscription, error) {

	var takerOrderRule []interface{}
	for _, takerOrderItem := range takerOrder {
		takerOrderRule = append(takerOrderRule, takerOrderItem)
	}
	var instrumentRule []interface{}
	for _, instrumentItem := range instrument {
		instrumentRule = append(instrumentRule, instrumentItem)
	}
	var orderModeRule []interface{}
	for _, orderModeItem := range orderMode {
		orderModeRule = append(orderModeRule, orderModeItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Trade", takerOrderRule, instrumentRule, orderModeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeTrade)
				if err := _Exchange.contract.UnpackLog(event, "Trade", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTrade is a log parse operation binding the contract event 0x29137367c7b4eb7bae1eb61d747d283207df8175f051513d11286cff169db49f.
//
// Solidity: event Trade(bytes32 indexed takerOrder, uint256 indexed instrument, uint256 indexed orderMode, address taker, bool isBuy, uint256 amount)
func (_Exchange *ExchangeFilterer) ParseTrade(log types.Log) (*ExchangeTrade, error) {
	event := new(ExchangeTrade)
	if err := _Exchange.contract.UnpackLog(event, "Trade", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the Exchange contract.
type ExchangeUpgradedIterator struct {
	Event *ExchangeUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeUpgraded represents a Upgraded event raised by the Exchange contract.
type ExchangeUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*ExchangeUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeUpgradedIterator{contract: _Exchange.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *ExchangeUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeUpgraded)
				if err := _Exchange.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Exchange *ExchangeFilterer) ParseUpgraded(log types.Log) (*ExchangeUpgraded, error) {
	event := new(ExchangeUpgraded)
	if err := _Exchange.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExchangeVersionInitializedIterator is returned from FilterVersionInitialized and is used to iterate over the raw logs and unpacked data for VersionInitialized events raised by the Exchange contract.
type ExchangeVersionInitializedIterator struct {
	Event *ExchangeVersionInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExchangeVersionInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExchangeVersionInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExchangeVersionInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExchangeVersionInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExchangeVersionInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExchangeVersionInitialized represents a VersionInitialized event raised by the Exchange contract.
type ExchangeVersionInitialized struct {
	NewVersion *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterVersionInitialized is a free log retrieval operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) FilterVersionInitialized(opts *bind.FilterOpts, newVersion []*big.Int) (*ExchangeVersionInitializedIterator, error) {

	var newVersionRule []interface{}
	for _, newVersionItem := range newVersion {
		newVersionRule = append(newVersionRule, newVersionItem)
	}

	logs, sub, err := _Exchange.contract.FilterLogs(opts, "VersionInitialized", newVersionRule)
	if err != nil {
		return nil, err
	}
	return &ExchangeVersionInitializedIterator{contract: _Exchange.contract, event: "VersionInitialized", logs: logs, sub: sub}, nil
}

// WatchVersionInitialized is a free log subscription operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) WatchVersionInitialized(opts *bind.WatchOpts, sink chan<- *ExchangeVersionInitialized, newVersion []*big.Int) (event.Subscription, error) {

	var newVersionRule []interface{}
	for _, newVersionItem := range newVersion {
		newVersionRule = append(newVersionRule, newVersionItem)
	}

	logs, sub, err := _Exchange.contract.WatchLogs(opts, "VersionInitialized", newVersionRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExchangeVersionInitialized)
				if err := _Exchange.contract.UnpackLog(event, "VersionInitialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVersionInitialized is a log parse operation binding the contract event 0x7a621ac638ec0ed2c353a3800daf6854f8682f565af567ad99fc910f4755938d.
//
// Solidity: event VersionInitialized(uint256 indexed newVersion)
func (_Exchange *ExchangeFilterer) ParseVersionInitialized(log types.Log) (*ExchangeVersionInitialized, error) {
	event := new(ExchangeVersionInitialized)
	if err := _Exchange.contract.UnpackLog(event, "VersionInitialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
